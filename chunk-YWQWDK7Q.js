import{a as S}from"./chunk-3MBKXCQY.js";import{a as g,b as Z,c as k,d as q}from"./chunk-I4TW3U2S.js";import{f as O}from"./chunk-QUZEX4CN.js";import{a as L}from"./chunk-4YTM754S.js";import{b as G}from"./chunk-NX5B6XBR.js";import{b as J}from"./chunk-6RBQSBA2.js";import{o as w}from"./chunk-AUAZP44J.js";import{b as P}from"./chunk-NFIPKH6V.js";import{a as b,b as N,f as D}from"./chunk-VTHXE323.js";function I(d){return d instanceof L}function W(d,s,R){return D(this,null,function*(){let m=[],i=[],u={},c={},v=J(d),{path:y}=v;I(s.stops)&&g(s.stops.features,i,"stops.features",u),I(s.pointBarriers)&&g(s.pointBarriers.features,i,"pointBarriers.features",u),I(s.polylineBarriers)&&g(s.polylineBarriers.features,i,"polylineBarriers.features",u),I(s.polygonBarriers)&&g(s.polygonBarriers.features,i,"polygonBarriers.features",u);let B=yield G(i);for(let a in u){let p=u[a];m.push(a),c[a]=B.slice(p[0],p[1])}if(k(c,m)){let a=null;try{a=yield q(y,s.apiKey,R)}catch{}a&&!a.hasZ&&Z(c,m)}for(let a in c)c[a].forEach((p,f)=>{P(s,a)[f].geometry=p});let h=N(b({},R),{query:N(b(b({},v.query),O(s)),{f:"json"})}),E=y.endsWith("/solve")?y:`${y}/solve`,{data:T}=yield w(E,h);return x(T)})}function x(d){let{barriers:s,checksum:R,directionLines:m,directionPoints:i,directions:u,messages:c,polygonBarriers:v,polylineBarriers:y,routes:B,stops:h,traversedEdges:E,traversedJunctions:T,traversedTurns:a}=d,p=e=>{let t=n.find(o=>o.routeName===e);if(t!=null)return t;let r={routeId:n.length+1,routeName:e};return n.push(r),r},f=e=>{let t=n.find(o=>o.routeId===e);if(t!=null)return t;let r={routeId:e,routeName:null};return n.push(r),r},n=[];B?.features.forEach((e,t)=>{e.geometry.spatialReference=B.spatialReference??void 0;let r=e.attributes.Name,o=t+1;n.push({routeId:o,routeName:r,route:e})}),u?.forEach(e=>{let{routeName:t}=e;p(t).directions=e});let j=(h?.features.every(e=>e.attributes.RouteName==null)??!1)&&n.length>0?n[0].routeName:null;return h?.features.forEach(e=>{e.geometry&&(e.geometry.spatialReference??=h.spatialReference??void 0);let t=j??e.attributes.RouteName,r=p(t);r.stops??=[],r.stops.push(e)}),m?.features.forEach(e=>{let t=e.attributes.RouteID,r=f(t),{geometryType:o,spatialReference:l}=m;r.directionLines??={features:[],geometryType:o,spatialReference:l},r.directionLines.features.push(e)}),i?.features.forEach(e=>{let t=e.attributes.RouteID,r=f(t),{geometryType:o,spatialReference:l}=i;r.directionPoints??={features:[],geometryType:o,spatialReference:l},r.directionPoints.features.push(e)}),E?.features.forEach(e=>{let t=e.attributes.RouteID,r=f(t),{geometryType:o,spatialReference:l}=E;r.traversedEdges??={features:[],geometryType:o,spatialReference:l},r.traversedEdges.features.push(e)}),T?.features.forEach(e=>{let t=e.attributes.RouteID,r=f(t),{geometryType:o,spatialReference:l}=T;r.traversedJunctions??={features:[],geometryType:o,spatialReference:l},r.traversedJunctions.features.push(e)}),a?.features.forEach(e=>{let t=e.attributes.RouteID,r=f(t);r.traversedTurns??={features:[]},r.traversedTurns.features.push(e)}),S.fromJSON({barriers:s,checksum:R,messages:c,polygonBarriers:v,polylineBarriers:y,routeResults:n})}export{W as a};
