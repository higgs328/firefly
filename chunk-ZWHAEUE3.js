import{a as C}from"./chunk-E56W4PK4.js";import{a as U}from"./chunk-G4DZJMGT.js";import{f as T}from"./chunk-CCJU4DSH.js";import{a as m}from"./chunk-QGVBCWUY.js";import{e as d}from"./chunk-NFIPKH6V.js";import{l as B}from"./chunk-5QEXLALV.js";import{b as v}from"./chunk-YOFFGXOB.js";import{g as k}from"./chunk-XRGPJ3QY.js";import{b}from"./chunk-2LI2GKBQ.js";var w=class{constructor(e=null,r=null,n=null){this.minValue=e,this.maxValue=r,this.noDataValue=n}};var A,g=A=class extends T{static createEmptyBand(t,e){return new(A.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];let e=t[0].length,r=new Uint8Array(e).fill(255);for(let n=0;n<t.length;n++){let a=t[n];for(let l=0;l<e;l++)a[l]||(r[l]=0)}return r}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new v("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new w)}getAsRGBA(){let t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){let t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(r=>R(r,this.mask));let t=this.mask,e=0;if(t!=null)for(let r=0;r<t.length;r++)t[r]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;let[e,r]=C(t),n=this.pixels,a=this.width*this.height,l=n.length,s,p,i,u=[];for(let c=0;c<l;c++){i=A.createEmptyBand(t,a),s=n[c];for(let o=0;o<a;o++)p=s[o],i[o]=p>r?r:p<e?e:p;u.push(i)}this.pixels=u,this.pixelType=t}extractBands(t){let{pixels:e,statistics:r}=this;if(t==null||t.length===0||!e||e.length===0)return this;let n=e.length,a=t.some(o=>o>=e.length),l=n===t.length&&!t.some((o,x)=>o!==x);if(a||l)return this;let s=this.bandMasks?.length===n?t.map(o=>this.bandMasks[o]):void 0,{mask:p,validPixelCount:i}=this,{width:u,height:c}=this;return s?.length&&(p=A.combineBandMasks(s),i=p.filter(o=>!!o).length),new A({pixelType:this.pixelType,width:u,height:c,mask:p,bandMasks:s,validPixelCount:i,maskIsAlpha:this.maskIsAlpha,pixels:t.map(o=>e[o]),statistics:r&&t.map(o=>r[o])})}clone(){let t=new A({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount}),e;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.bandMasks&&(t.bandMasks=this.bandMasks.map(n=>new Uint8Array(n)));let r=A.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];let n=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=n?this.pixels[e].slice():new r(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=b(this.statistics[e]);return t.premultiplyAlpha=this.premultiplyAlpha,t}_fillFrom8Bit(t){let{mask:e,maskIsAlpha:r,premultiplyAlpha:n,pixels:a}=this;if(!t||!a?.length)return void k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let l,s,p,i;l=s=p=a[0],a.length>=3?(s=a[1],p=a[2]):a.length===2&&(s=a[1]);let u=new Uint32Array(t),c=this.width*this.height;if(l.length===c)if(e!=null&&e.length===c)if(r)for(i=0;i<c;i++){let o=e[i];if(o){let x=o/255;u[i]=n?o<<24|p[i]*x<<16|s[i]*x<<8|l[i]*x:o<<24|p[i]<<16|s[i]<<8|l[i]}}else for(i=0;i<c;i++)e[i]&&(u[i]=255<<24|p[i]<<16|s[i]<<8|l[i]);else for(i=0;i<c;i++)u[i]=255<<24|p[i]<<16|s[i]<<8|l[i];else k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){let{pixels:e,mask:r,statistics:n}=this;if(!t||!e?.length)return void k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let a=this.pixelType,l=1,s=0,p=1;if(n&&n.length>0){for(let f of n)if(f.minValue!=null&&(s=Math.min(s,f.minValue)),f.maxValue!=null&&f.minValue!=null){let P=f.maxValue-f.minValue;p=Math.max(p,P)}l=255/p}else{let f=255;a==="s8"?(s=-128,f=127):a==="u16"?f=65535:a==="s16"?(s=-32768,f=32767):a==="u32"?f=4294967295:a==="s32"?(s=-2147483648,f=2147483647):a==="f32"?(s=-34e38,f=34e38):a==="f64"&&(s=-Number.MAX_VALUE,f=Number.MAX_VALUE),l=255/(f-s)}let i=new Uint32Array(t),u=this.width*this.height,c,o,x,h,y;if(c=o=x=e[0],c.length!==u)return k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(o=e[1],e.length>=3&&(x=e[2]),r!=null&&r.length===u)for(h=0;h<u;h++)r[h]&&(i[h]=255<<24|(x[h]-s)*l<<16|(o[h]-s)*l<<8|(c[h]-s)*l);else for(h=0;h<u;h++)i[h]=255<<24|(x[h]-s)*l<<16|(o[h]-s)*l<<8|(c[h]-s)*l;else if(r!=null&&r.length===u)for(h=0;h<u;h++)y=(c[h]-s)*l,r[h]&&(i[h]=255<<24|y<<16|y<<8|y);else for(h=0;h<u;h++)y=(c[h]-s)*l,i[h]=255<<24|y<<16|y<<8|y}_fillFrom32Bit(t){let{pixels:e,mask:r}=this;if(!t||!e?.length)return k.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let n,a,l,s;n=a=l=e[0],e.length>=3?(a=e[1],l=e[2]):e.length===2&&(a=e[1]);let p=this.width*this.height;if(n.length!==p)return k.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let i=0;if(r!=null&&r.length===p)for(s=0;s<p;s++)t[i++]=n[s],t[i++]=a[s],t[i++]=l[s],t[i++]=1&r[s];else for(s=0;s<p;s++)t[i++]=n[s],t[i++]=a[s],t[i++]=l[s],t[i++]=1}};function R(t,e){let r=1/0,n=-1/0,a=t.length,l,s=0;if(e!=null)for(l=0;l<a;l++)e[l]&&(s=t[l],r=s<r?s:r,n=s>n?s:n);else for(l=0;l<a;l++)s=t[l],r=s<r?s:r,n=s>n?s:n;return new w(r,n)}m([d({json:{write:!0}})],g.prototype,"width",void 0),m([d({json:{write:!0}})],g.prototype,"height",void 0),m([d({json:{write:!0}})],g.prototype,"pixelType",void 0),m([U("pixelType")],g.prototype,"castPixelType",null),m([d({json:{write:!0}})],g.prototype,"validPixelCount",void 0),m([d({json:{write:!0}})],g.prototype,"mask",void 0),m([d({json:{write:!0}})],g.prototype,"maskIsAlpha",void 0),m([d({json:{write:!0}})],g.prototype,"pixels",void 0),m([d()],g.prototype,"premultiplyAlpha",void 0),m([d({json:{write:!0}})],g.prototype,"statistics",void 0),m([d({json:{write:!0}})],g.prototype,"depthCount",void 0),m([d({json:{write:!0}})],g.prototype,"noDataValues",void 0),m([d({json:{write:!0}})],g.prototype,"bandMasks",void 0),g=A=m([B("esri.layers.support.PixelBlock")],g);var D=g;export{w as a,D as b};
