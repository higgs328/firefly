import{a as X,b as Y,m as v}from"./chunk-FKASYKK7.js";import"./chunk-LAAJ7BOG.js";import{e as P,s as M,t as w,u as G,v as _}from"./chunk-A2QQP5DF.js";import{a as f,c}from"./chunk-LTHAIW3V.js";import"./chunk-RRQS6PLL.js";import"./chunk-WFHQTMIY.js";import"./chunk-XAZOVQGA.js";import{b as o,h,o as l,ub as i,v as x,y as p,z as g,za as k}from"./chunk-V3KEO7AJ.js";import"./chunk-MDZTV2VL.js";import"./chunk-RNC4P66O.js";import"./chunk-7LHOQXZT.js";import"./chunk-BCREO4Q5.js";import"./chunk-U4QEPZJ3.js";import"./chunk-KJUZWSCL.js";import"./chunk-3WO6D7MU.js";import"./chunk-BUZ3SPLE.js";import"./chunk-KVM6SHDX.js";import"./chunk-EQZWYK27.js";import"./chunk-ZQIC5NFT.js";import"./chunk-VIEK2X23.js";import"./chunk-XKIFGPJO.js";import"./chunk-PEW2PLAN.js";import"./chunk-Q6Y4JG7Q.js";import"./chunk-7F5DJLJT.js";import"./chunk-CX5IFQZJ.js";import"./chunk-NJWTSROP.js";import"./chunk-D3R25AF2.js";import"./chunk-ARRCN5K3.js";import"./chunk-G4DZJMGT.js";import"./chunk-X2B63YVS.js";import"./chunk-BAEF3CT6.js";import"./chunk-AUAZP44J.js";import"./chunk-PVDFCTA4.js";import"./chunk-KNVXE32P.js";import"./chunk-76ATOSLU.js";import"./chunk-CCJU4DSH.js";import"./chunk-QGVBCWUY.js";import"./chunk-MYO4NP2N.js";import"./chunk-NFIPKH6V.js";import"./chunk-JPU2PQZC.js";import"./chunk-5QEXLALV.js";import"./chunk-P6QFA5MM.js";import"./chunk-DGTD7Y73.js";import"./chunk-LI2SX4T6.js";import"./chunk-BWO7LS2H.js";import"./chunk-HEVQSRJ2.js";import"./chunk-OVHPPCBL.js";import"./chunk-SNFOAZZQ.js";import"./chunk-AML4XSEF.js";import"./chunk-4PTIEWMT.js";import"./chunk-TG2UTNEO.js";import"./chunk-YOFFGXOB.js";import"./chunk-XRGPJ3QY.js";import"./chunk-6MRUJ2UW.js";import"./chunk-2LI2GKBQ.js";import{y as C}from"./chunk-QBWJMFH5.js";import"./chunk-VTHXE323.js";var d=class{getOperatorType(){return 10113}supportsCurves(){return!1}accelerateGeometry(e,t,r){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,r){return new y(e,t,r)}execute(e,t){let r=new c([e]),n=this.executeMany(r,!1,t).next();return n||x("null output"),n}minimumBoundingCircle(e,t,r,n){return G(e,t,r)}},y=class extends f{constructor(e,t,r){super(),this.m_geometryCursor=e,this.m_bMerge=t,this.m_progressTracker=r}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge)return this.mergedMinimumBoundingCircle();let e=this.m_geometryCursor.next();return e?this.minimumBoundingCircle(e):null}getGeometryID(){return this.m_geometryCursor.getGeometryID()}minimumBoundingCircle(e){if(p(e),g(e),this.m_progressTracker?.checkProgress(),e.isEmpty())return e.clone();let t=e.getGeometryType();if(t===o.enumPoint)return this.makeCircle([e.getXY()],1);if(t===o.enumLine){let r=e,n=[r.getStartXY(),r.getEndXY()];return this.makeCircle(n,2)}if(t===o.enumEnvelope){let r=e,n=k(i,2);return r.queryCorner(0,n[0]),r.queryCorner(2,n[1]),this.makeCircle(n,2)}if(h(t)){let r=e,n=[0,0,0],s=w(r,n),m=new Array(s);for(let a=0;a<s;++a)m[a]=r.getXY(n[a]);return this.makeCircle(m,s)}l("Geometry type not supported.")}makeCircle(e,t){let r=new _,n=new M;if(t===1)n.constructCircleRadius(0,e[0],!1);else if(t===2){let s=i.lerp(e[0],e[1],.5),m=i.distance(e[0],s),a=i.distance(e[1],s);n.constructCircleRadius(Math.max(m,a),s,!1)}else if(t===3){let s=i.calculateCircleCenterFromThreePoints(e[0],e[1],e[2]),m=i.distance(e[0],s),a=i.distance(e[1],s),B=i.distance(e[2],s);n.constructCircleRadius(Math.max(m,a,B),s,!1)}return r.addPathFromClosedSegment(n,!1),r}mergedMinimumBoundingCircle(){let e=null,t=this.m_geometryCursor.next();if(!t)return null;e=new P;let r=e.getImpl();do switch(p(t),g(t),this.m_progressTracker?.checkProgress(),t.getGeometryType()){case o.enumPoint:r.addPoint2D(t.getXY());break;case o.enumLine:r.addPoint2D(t.getStartXY()),r.addPoint2D(t.getEndXY());break;case o.enumEnvelope:for(let n=0;n<4;++n){let s=new i;t.queryCorner(n,s),r.addPoint2D(s)}break;case o.enumMultiPoint:case o.enumPolyline:case o.enumPolygon:{let n=t.getImpl();for(let s=0,m=n.getPointCount();s<m;s++)r.addPoint2D(n.getXY(s));break}default:l("Geometry type not supported.")}while(t=this.m_geometryCursor.next());return this.minimumBoundingCircle(e)}},D=new d;function T(u,e){let t=D.executeMany(new c(u),e,null);return Array.from(t)}function b(){return D.supportsCurves()}function j(u){return S([u])[0]}function S(u,e={}){let{merge:t=!1}=e,r=u.map(Y),n=X(u);return T(r,t).map(s=>v(s,n)).filter(C)}var z=b();export{j as execute,S as executeMany,z as supportsCurves};
