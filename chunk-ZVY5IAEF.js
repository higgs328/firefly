import{c as D,g as L}from"./chunk-66BPZDMW.js";import{$ as T,Z as N,_ as p,aa as I,i as E,l as S}from"./chunk-KALOJIUA.js";import{c as A}from"./chunk-KMMTNF7G.js";import{a as F}from"./chunk-JLPLCY2B.js";import{b as x}from"./chunk-32OAXCA4.js";import{c as w,d as h}from"./chunk-K5T5FD5C.js";import{b as f}from"./chunk-YOFFGXOB.js";import{g as v}from"./chunk-XRGPJ3QY.js";import{f as b}from"./chunk-VTHXE323.js";var d=()=>v.getLogger("esri.layers.support.labelFormatUtils"),g={type:"simple",evaluate:()=>null},V={getAttribute:(n,t)=>n.field(t)};function z(n,t,u){return b(this,null,function*(){if(!n||!n.symbol||!t)return g;let l=n.where,o=D(n),a;if(o.type==="arcade"){let i=S(o.expression),s=t.get(i);if(s&&(N(s)||p(s)||T(s)))a={type:"simple",evaluate(e){let r="attributes"in e?e.attributes?.[s.name]:e.field(s.name);return r==null?"":r.toString()}};else{let e=yield A(o.expression,u,t);if(e==null)return g;a={type:"arcade",evaluate(r,c){try{let m="attributes"in r?e.repurposeFeature(r):r;m.contextTimeZone=c??null;let y=e.evaluate({$view:{timeZone:c},$feature:m},e.services);if(y!=null)return y.toString()}catch(m){d().error(new f("arcade-expression-error","Encountered an error when evaluating label expression for feature",{error:m,feature:r,expression:o}))}return null},needsHydrationToEvaluate:()=>L(o.expression)==null}}}else a={type:"simple",evaluate:i=>o.expression.replaceAll(/{[^}]*}/g,s=>{let e=s.slice(1,-1),r=t.get(e);if(!r)return s;let c=null;return c="attributes"in i?i?.attributes?.[r.name]:i.field(r.name),c==null?"":Z(c,r)})};if(l){let i;try{i=yield F(l,t)}catch(e){return d().error(new f("bad-where-clause","Encountered an error when evaluating where clause, ignoring",{where:l,error:e})),g}let s=a.evaluate;a.evaluate=(e,r)=>{let c="attributes"in e?void 0:V;try{if(i.testFeature(e,c))return s(e,r)}catch(m){d().error(new f("bad-where-clause","Encountered an error when evaluating where clause for feature",{where:l,feature:e,error:m}))}return null}}return a})}function Z(n,t){if(n==null)return"";let u=t.domain;if(u){if(u.type==="codedValue"||u.type==="coded-value"){let o=n;for(let a of u.codedValues)if(a.code===o)return a.name}else if(u.type==="range"){let{max:o,min:a}=E(t),i=+n;if(a!=null&&o!=null&&a<=i&&i<=o)return u.name}}let l=n;return I(t)?l=h(l,w("short-date")):p(t)&&(l=x(+l)),l||""}export{z as a,Z as b};
