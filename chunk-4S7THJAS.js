import{b as j}from"./chunk-QSQIQSC6.js";import{a as $,c as tt}from"./chunk-Y7XRSFOZ.js";import{a as Z}from"./chunk-QCZ3ZIGQ.js";import{p as X}from"./chunk-DJW5LMRG.js";import{a as Y}from"./chunk-DEH76MSI.js";import{a as M}from"./chunk-ALWV3RJ2.js";import{a as c,c as g,d as W,o as _,y as w}from"./chunk-6B5XFA6F.js";import{a as I,d as L,f as Q,g as U}from"./chunk-ZTOZWLEE.js";import{a as p}from"./chunk-BOVYXYHK.js";var st=class{constructor(){this._transform=M(),this._transformInverse=new u({value:this._transform},Q,M),this._transformInverseTranspose=new u(this._transformInverse,L,M),this._transformTranspose=new u({value:this._transform},L,M),this._transformInverseRotation=new u({value:this._transform},X,Y)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){I(this._transform,t)}multiplyTransform(t){U(this._transform,this._transform,t)}set(t){I(this._transform,t),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,r){this.setTransformMatrix(t),this.multiplyTransform(r),this._invalidateLazyTransforms()}},u=class{constructor(t,r,e){this._original=t,this._update=r,this._dirty=!0,this._transform=e()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}},q=class{constructor(t=0){this.offset=t,this.tmpVertex=p()}applyToVertex(t,r,e){let i=g(R,t,r,e),o=W(it,i,this.localOrigin),n=this.offset/c(o);return _(this.tmpVertex,i,o,n),this.tmpVertex}applyToAabb(t){let r=nt,e=ot,i=ft;for(let s=0;s<3;++s)r[s]=t[0+s]+this.localOrigin[s],e[s]=t[3+s]+this.localOrigin[s],i[s]=r[s];let o=this.applyToVertex(r[0],r[1],r[2]);for(let s=0;s<3;++s)t[s]=o[s],t[s+3]=o[s];let n=s=>{let a=this.applyToVertex(s[0],s[1],s[2]);for(let l=0;l<3;++l)t[l]=Math.min(t[l],a[l]),t[l+3]=Math.max(t[l+3],a[l])};for(let s=1;s<8;++s){for(let a=0;a<3;++a)i[a]=s&1<<a?e[a]:r[a];n(i)}let h=0;for(let s=0;s<3;++s)r[s]*e[s]<0&&(h|=1<<s);if(h!==0&&h!==7){for(let s=0;s<8;++s)if(!(h&s)){for(let a=0;a<3;++a)i[a]=h&1<<a?0:s&1<<a?r[a]:e[a];n(i)}}for(let s=0;s<3;++s)t[s]-=this.localOrigin[s],t[s+3]-=this.localOrigin[s];return t}},z=class{constructor(t=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=p(),this._tmpMbs=j(),this._tmpObb=new $,this._resetOffset(t)}_resetOffset(t){this._offset=t,this._totalOffset=t}set offset(t){this._resetOffset(t)}get offset(){return this._offset}set componentOffset(t){this._totalOffset=this._offset+t}set localOrigin(t){this.componentLocalOriginLength=c(t)}applyToVertex(t,r,e){let i=g(R,t,r,e),o=g(it,t,r,e+this.componentLocalOriginLength),n=this._totalOffset/c(o);return _(this._tmpVertex,i,o,n),this._tmpVertex}applyToAabb(t){let r=this.componentLocalOriginLength,e=t[0],i=t[1],o=t[2]+r,n=t[3],h=t[4],s=t[5]+r,a=Math.abs(e),l=Math.abs(i),T=Math.abs(o),y=Math.abs(n),V=Math.abs(h),d=Math.abs(s),G=.5*(1+Math.sign(e*n))*Math.min(a,y),S=.5*(1+Math.sign(i*h))*Math.min(l,V),B=.5*(1+Math.sign(o*s))*Math.min(T,d),D=Math.max(a,y),F=Math.max(l,V),k=Math.max(T,d),C=Math.sqrt(G*G+S*S+B*B),E=Math.sign(a+e),H=Math.sign(l+i),J=Math.sign(T+o),K=Math.sign(y+n),N=Math.sign(V+h),P=Math.sign(d+s),m=this._totalOffset;if(C<m)return t[0]-=(1-E)*m,t[1]-=(1-H)*m,t[2]-=(1-J)*m,t[3]+=K*m,t[4]+=N*m,t[5]+=P*m,t;let b=m/Math.sqrt(D*D+F*F+k*k),O=m/C,v=O-b,x=-v;return t[0]+=e*(E*x+O),t[1]+=i*(H*x+O),t[2]+=o*(J*x+O),t[3]+=n*(K*v+b),t[4]+=h*(N*v+b),t[5]+=s*(P*v+b),t}applyToMbs(t){let r=c(t),e=this._totalOffset/r;return _(this._tmpMbs,t,t,e),this._tmpMbs[3]=t[3]+t[3]*this._totalOffset/r,this._tmpMbs}applyToObb(t){return tt(t,this._totalOffset,this._totalOffset,Z.Global,this._tmpObb),this._tmpObb}},A=class{constructor(t=0){this.offset=t,this.sphere=j(),this.tmpVertex=p()}applyToVertex(t,r,e){let i=this.objectTransform.transform,o=g(R,t,r,e),n=w(o,o,i),h=this.offset/c(n);_(n,n,n,h);let s=this.objectTransform.inverse;return w(this.tmpVertex,n,s),this.tmpVertex}applyToMinMax(t,r){let e=this.offset/c(t);_(t,t,t,e);let i=this.offset/c(r);_(r,r,r,i)}applyToAabb(t){let r=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*r,t[1]+=t[1]*r,t[2]+=t[2]*r;let e=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*e,t[4]+=t[4]*e,t[5]+=t[5]*e,t}applyToBoundingSphere(t){let r=c(t),e=this.offset/r;return _(this.sphere,t,t,e),this.sphere[3]=t[3]+t[3]*this.offset/r,this.sphere}},rt=new A;function Ot(f){return f!=null?(rt.offset=f,rt):null}var et=new z;function vt(f){return f!=null?(et.offset=f,et):null}var at=new q;function Tt(f){return f!=null?(at.offset=f,at):null}var yt="terrain",R=p(),it=p(),nt=p(),ot=p(),ft=p();export{st as a,Ot as b,vt as c,Tt as d,yt as e};
