import{a as Ge}from"./chunk-ZO3XNOAM.js";import"./chunk-YKYZUPXZ.js";import{a as D,b as v,c as Ie}from"./chunk-E26EFI7P.js";import{Bb as J,Ca as z,Da as b,L as Ce,Ra as ce,S as T,T as we,U as re,V as Pe,W as ie,Y as ae,Z as _e,_a as Ee,a as te,bb as Te,kb as X,r as Ae,v as pe,xb as H,zb as me}from"./chunk-A2QQP5DF.js";import{a as ye}from"./chunk-LTHAIW3V.js";import"./chunk-RRQS6PLL.js";import{ea as Q,k as R}from"./chunk-WFHQTMIY.js";import"./chunk-XAZOVQGA.js";import{Ea as ee,a as se,b as G,i as Ne,o as I,oa as $,t as Z,ub as j,v as xe,za as oe}from"./chunk-V3KEO7AJ.js";import{d as L,e as M}from"./chunk-QGVBCWUY.js";import"./chunk-VTHXE323.js";var je=class{getOperatorType(){return 10501}supportsCurves(){return!0}accelerateGeometry(e,s,t){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,s,t,u,g,d){if(s.isNAN()&&I("NAN xy coordinates are not allowed"),e.isEmpty())return D();if(Number.isNaN(u)&&(u=0),u>=0||I("maxDeviationMeters"),e.getDimension()===0)return this.getNearestVertex(e,s,t);let S=e.getGeometryType();if(S===G.enumGeometryCollection){let w=e,p=D();for(let E=0,U=w.getGeometryCount();E<U;++E){let V=w.getGeometry(E),F=this.getNearestCoordinate(V,s,t,u,g,d);if(!F.isEmpty()){if(F.m_distance===0)return F;F.m_distance>=p.m_distance||(p=F,p.m_geometryIndex=E)}}return p}if(S===G.enumEnvelope){let w=new pe;return w.addEnvelope(e,!1),this.getNearestCoordinate(w,s,t,u,g,d)}Ne(S)||Z("Operation is not implemented for this geometry type");let h=e;if((g||d)&&S===G.enumPolygon){let w=()=>{let p=v(s,-1,0);return p.m_bRightSide=!0,p};if(t.isPannable()){let p=new b().foldInto360Range(new Q(s),t);if(p.isEmpty())return D();let E=new b().foldInto360Range(e,t);if(E.isEmpty())return D();if(new ce().execute(E,p,t,null)&&g)return w()}else{let p=new b().clipToSpatialReference(new Q(s),t,null,1);if(p.isEmpty())return D();let E=Ee(h,t,0,null);if(E.isEmpty())return D();if(new ce().execute(E,p,t,null)&&g)return w()}}let r=t!==t.getGCS()?t.getSRToGCSTransform():null,i=new j;if(r?new b().transform(r,[s],1,[i],!1):i.assign(s),i.isNAN())return D();let y=De(h,s,t,1),c=y.m_distance;if(c===0)return y;Number.isNaN(c)?c=Number.POSITIVE_INFINITY:c*=1+1e-7;let N=t.getGCS(),C=N.getUnit().getUnitToBaseFactor(),_=i.clone();_.scale(C);let a=X();t.querySpheroidData(a);let o=T(a.majorSemiAxis,a.e2,_),f=_e(a.majorSemiAxis,a.e2),A=new ge(h.querySegmentIterator());u===0&&(u=.01);let m=a.majorSemiAxis*Ae(45),n=new Ge().executeMany(A,t,m,u,0,null),l=[],O=-1,ne=new R,k=new Ce;for(let w=n.next();w!==null;w=n.next()){if(w.isEmpty())continue;let p=n.getGeometryID(),E=e.getPathIndexFromPointIndex(p);e.isClosedPath(E)&&h.getPathEnd(E);let U=w;for(let V=0,F=U.getPathCount();V<F;++V){l.length=0;for(let P=U.getPathStart(V),B=U.getPathEnd(V);P<B;++P)l.push(U.getXY(P));if(r&&new b().transform(r,l,l.length,l,!1),l.length>3){let P=ue(l,l.length,i,N,1);if(P.m_distance<c){c=P.m_distance,ne.assign(T(a.majorSemiAxis,a.e2,P.m_coordinate.mul(C))),O=p;let B=P.m_vertexIndex;B+1===l.length&&(B-=1),U.getSegmentBuffer(B,k,!0)}}l.forEach(P=>P.mulThis(C));let K=T(a.majorSemiAxis,a.e2,l[0]),Re=new R;for(let P=1,B=l.length;P<B;++P){let W=T(a.majorSemiAxis,a.e2,l[P]);if(Pe(f,o,K,W,Re)<c){let{first:Ye,second:Ue}=ie(a.majorSemiAxis,a.e2,o,K,W,2,null);if(Ue<=c){let Se=new R,{first:Fe,second:he}=ie(a.majorSemiAxis,a.e2,o,K,W,0,Se);he<c&&(c=he,ne.assign(Se),O=p,U.getSegmentBuffer(P-1,k,!0))}}K.assign(W)}}}if(!Number.isFinite(c))return D();O===-1&&I("");let q=we(a.majorSemiAxis,a.e2,ne);q.divThis(C);let Y=q.clone(),fe=t!==t.getGCS()?t.getGCSToSRTransform():null;fe&&new b().transform(fe,[q],1,[Y],!1),Y.isNAN()&&xe("closestPoint2DSr.isNAN()"),se(!k.empty());let be=k.get().getClosestCoordinate(Y,!1);Y.assign(k.get().getCoord2D(be)),r?new b().transform(r,[Y],1,[q],!1):q.assign(Y),se(!q.isNAN());let ve=this.getNearestVertex(new Q(q),i,t.getGCS()),de=v(Y,O,ve.m_distance);if(d&&e.getDimension()>0){let w=Ie(e,s,-1,-1),p=w!==0&&w!==3;de.m_bRightSide=p}return de}getNearestVertex(e,s,t){if(s.isNAN()&&I("NAN xy coordinates are not allowed"),e.isEmpty())return D();switch(e.getGeometryType()){case G.enumPoint:return le(e,s,t);case G.enumMultiPoint:case G.enumPolyline:case G.enumPolygon:return De(e,s,t);default:Z("")}}getNearestVertexPoint2D(e,s,t,u){return ue(e,s,t,u)}getNearestVertices(e,s,t,u,g){if(s.isNAN()&&I("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case G.enumPoint:{let d=le(e,s,t);if(!d.isEmpty()&&d.m_distance<u&&g>=1){let S=[];return S.push(d),S}return[]}case G.enumMultiPoint:case G.enumPolyline:case G.enumPolygon:return qe(e,s,t,u,g);default:Z("")}}};function le(x,e,s){let t={stack:[],error:void 0,hasError:!1};try{if(s.getCoordinateSystemType()===0&&I("Cannot use local SR"),s.getCoordinateSystemType()!==1){let i=new Array(2);i[0]=x.getXY(),i[1]=e.clone();let y=oe(j,2);Te(s,i,2,y)!==2&&I("Point cannot be projected to GCS");let c=s.getGCS(),N=le(new Q(y[0]),y[1],c);return v(N.m_coordinate,0,N.m_distance)}let u=s.getUnit().getUnitToBaseFactor(),g=x.getXY();g.scale(u);let d=e.clone();d.scale(u);let S=X();s.querySpheroidData(S);let h=L(t,new H,!1);J.geodeticDistance(S.majorSemiAxis,S.e2,g.x,g.y,d.x,d.y,h,null,null,me.PE_LINETYPE_GEODESIC);let r=x.getXY();return v(r,0,h.val)}catch(u){t.error=u,t.hasError=!0}finally{M(t)}}function De(x,e,s,t=0){s.getCoordinateSystemType()===0&&I("Cannot use local SR");let u=x.getAttributeStreamRef(0),g=x.getPointCount(),d=s.getGCS(),S=e.clone();if(s.getCoordinateSystemType()!==1){let m=s.getSRToGCSTransform();if(z(m,[e],1,[S],null),S.isNAN())return v(j.getNAN(),-1,Number.NaN);let n=new b().execute(x,m,null);u=n.getAttributeStreamRef(0),g=n.getPointCount()}let h=d.getUnit().getUnitToBaseFactor(),r=ee(g,0);for(let m=0;m<g;++m)r[m]=m;te(g,r);let i=X();d.querySpheroidData(i);let y=S.clone();y.scale(h);let c=T(i.majorSemiAxis,i.e2,y),N=-1,C=Number.MAX_VALUE,_=ae(i.majorSemiAxis,i.e2),a=g,o=new j,f=new j;for(let m=0;m<a;){if(u.queryPoint2D(2*r[m],o),o.isNAN())continue;f.assign(o),f.scale(h);let n=T(i.majorSemiAxis,i.e2,f);if(R.distance(n,c)>C){r[a-1]=$(r[m],r[m]=r[a-1]),a--;continue}let l=re(_,n,c);l<C&&(N=r[m],C=l),m++}if(i.e2!==0){let m={stack:[],error:void 0,hasError:!1};try{let n=L(m,new H,!1);for(let l=0;l<a;l++){if(u.queryPoint2D(2*r[l],o),o.isNAN())continue;f.assign(o),f.scale(h);let O=T(i.majorSemiAxis,i.e2,f);R.distance(O,c)>C||(J.geodeticDistance(i.majorSemiAxis,i.e2,y.x,y.y,f.x,f.y,n,null,null,t),n.val<C&&(N=r[l],C=n.val))}}catch(n){m.error=n,m.hasError=!0}finally{M(m)}}let A=new j;return N!==-1&&A.assign(x.getXY(N)),v(A,N,C)}function ue(x,e,s,t,u=0){t.getCoordinateSystemType()===0&&I("Cannot use local SR");let g=t.getGCS(),d=s.clone();if(t.getCoordinateSystemType()!==1){let o=t.getSRToGCSTransform();if(z(o,[s],1,[d],null),d.isNAN())return D();let f=oe(j,e);z(o,x,e,f,null);let A=ue(f,e,s,g,u);return A.isEmpty()?A:v(x[A.m_vertexIndex],A.m_vertexIndex,A.m_distance)}let S=g.getUnit().getUnitToBaseFactor(),h=ee(e,0);for(let o=0;o<e;++o)h[o]=o;te(e,h);let r=X();g.querySpheroidData(r);let i=d.clone();i.scale(S);let y=T(r.majorSemiAxis,r.e2,i),c=-1,N=Number.MAX_VALUE,C=ae(r.majorSemiAxis,r.e2),_=e;for(let o=0;o<_;){let f=x[h[o]];if(f.isNAN())continue;let A=f.clone();A.scale(S);let m=T(r.majorSemiAxis,r.e2,A);if(R.distance(m,y)>N){h[_-1]=$(h[o],h[o]=h[_-1]),_--;continue}let n=re(C,m,y);n<N&&(c=h[o],N=n),o++}if(r.e2!==0){let o={stack:[],error:void 0,hasError:!1};try{let f=L(o,new H,!1);for(let A=0;A<_;A++){let m=x[h[A]];if(m.isNAN())continue;let n=m.clone();n.scale(S);let l=T(r.majorSemiAxis,r.e2,n);R.distance(l,y)>N||(J.geodeticDistance(r.majorSemiAxis,r.e2,i.x,i.y,n.x,n.y,f,null,null,u),f.val<N&&(c=h[A],N=f.val))}}catch(f){o.error=f,o.hasError=!0}finally{M(o)}}let a=new j;return c!==-1&&a.assign(x[c]),v(a,c,N)}function qe(x,e,s,t,u){let g={stack:[],error:void 0,hasError:!1};try{s.getCoordinateSystemType()===0&&I("Cannot use local SR");let d=x.getAttributeStreamRef(0),S=x.getPointCount(),h=s.getGCS(),r=e.clone();if(s.getCoordinateSystemType()!==1){let n=s.getSRToGCSTransform();if(z(n,[e],1,[r],null),r.isNAN())return[];let l=new b().execute(x,n,null);d=l.getAttributeStreamRef(0),S=l.getPointCount()}let i=h.getUnit().getUnitToBaseFactor(),y=ee(S,0);for(let n=0;n<S;++n)y[n]=n;te(S,y);let c=X();h.querySpheroidData(c);let N=r.clone();N.scale(i);let C=T(c.majorSemiAxis,c.e2,N),_=[],a=S,o=new j,f=new j;for(let n=0;n<a;){if(d.queryPoint2D(2*y[n],o),o.isNAN())continue;f.assign(o),f.scale(i);let l=T(c.majorSemiAxis,c.e2,f);R.distance(l,C)>t?(y[a-1]=$(y[n],y[n]=y[a-1]),a--):n++}let A=(n,l)=>n.m_distance-l.m_distance,m=L(g,new H,!1);for(let n=0;n<a;n++)d.queryPoint2D(2*y[n],o),o.isNAN()||(J.geodeticDistance(c.majorSemiAxis,c.e2,N.x,N.y,o.x*i,o.y*i,m,null,null,me.PE_LINETYPE_GEODESIC),m.val<t&&_.push(v(o,y[n],m.val)));return _.sort(A),_.slice(0,u)}catch(d){g.error=d,g.hasError=!0}finally{M(g)}}var ge=class extends ye{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}};export{je as OperatorProximityGeodesic};
