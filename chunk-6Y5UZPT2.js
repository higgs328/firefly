import{a as st,d as Dt,e as ot,f as lt,g as At}from"./chunk-PREF6ZRE.js";import{a as zt,b as Ht,h as Et,k as Lt}from"./chunk-AFJIRAY7.js";import{a as Ct}from"./chunk-E424TX4V.js";import{b as it,d as vt,f as nt,g as Z,i as X,j as tt,k as bt,l as Pt,m as Bt,n as rt}from"./chunk-HD5Z6MAY.js";import{l as wt}from"./chunk-AULXBTED.js";import{p as Y,u as St,v as kt,y as _t,z as Mt}from"./chunk-Y3KWVZKS.js";import{f as Rt}from"./chunk-E56W4PK4.js";import{a as Tt}from"./chunk-2CC7WNFC.js";import{d as Wt}from"./chunk-PBAMEKFE.js";import{a as et}from"./chunk-DZFUQCB6.js";import{a as It}from"./chunk-PIHANKUA.js";import{m as $}from"./chunk-ZQIC5NFT.js";import{c as O}from"./chunk-VIEK2X23.js";import{a as gt}from"./chunk-7F5DJLJT.js";import{a as xt}from"./chunk-LXK2YRMG.js";import{g as dt,o as yt}from"./chunk-AUAZP44J.js";import{f as pt}from"./chunk-CCJU4DSH.js";import{a as k}from"./chunk-QGVBCWUY.js";import{e as b}from"./chunk-NFIPKH6V.js";import{l as ht}from"./chunk-5QEXLALV.js";import{i as ut}from"./chunk-P6QFA5MM.js";import{u as mt}from"./chunk-4PTIEWMT.js";import{b as ft}from"./chunk-YOFFGXOB.js";import{g as ct}from"./chunk-XRGPJ3QY.js";import{a as v,b as N,f as D}from"./chunk-VTHXE323.js";var Ot=8,Nt=256,qt=0,S=class extends pt{constructor(){super(...arguments),this._tileFetchQueue=new xt({concurrency:32,process:(t,e)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,N(v({},t.options),{signal:e}))}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t=N(v({},t),{ioConfig:v({resolution:null,bandIds:null,sampling:"closest",tileInfo:et.create()},t.ioConfig)})),t}get _isGlobalWrappableSource(){let{rasterInfo:t}=this,e=X(t.spatialReference);return e!=null&&t.extent.width>=e/2}get _hasNoneOrGCSShiftTransform(){let{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),this.datasetFormat==="Function"&&this.primaryRasters?.rasters?.forEach(e=>e.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+qt++}set url(t){this._set("url",dt(t,ct.getLogger(this)))}open(t){return D(this,null,function*(){return this._openPromise??=it().then(()=>this._open(t)),this._openPromise})}fetchTile(l,h,f){return D(this,arguments,function*(t,e,n,i={}){let o=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(t,e,n,o);return i=v({noClip:!0},i),this.fetchPixels(s,o.size[0],o.size[1],i)})}identify(n){return D(this,arguments,function*(t,e={}){t=ut(O,t).clone().normalize();let{multidimensionalDefinition:i,timeExtent:l}=e,{rasterInfo:h}=this,{hasMultidimensionalTranspose:f,multidimensionalInfo:o}=h,{transposedVariableName:s}=e,r=o!=null&&f&&(l!=null||Et(i));r&&!s&&(s=i!=null&&i.length>0?i[0].variableName??void 0:o.variables[0].name,e=N(v({},e),{transposedVariableName:s})),e=this._getRequestOptionsWithSliceId(e);let{spatialReference:a,extent:c}=h,{datumTransformation:m}=e,u=nt(t,a,m);if(!c.intersects(u))return{location:u,value:null};if(h.transform!=null){let W=h.transform.inverseTransform(u);if(!h.nativeExtent.intersects(W))return{location:W,value:null};u=W}let p=0,y=s!=null&&o!=null&&h.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){let W=this.primaryRasters.rasters[0];if(y)return W.identify(u,e);let{pixelSize:Q}=h,C=3,q=Q.x*C/2,J=Q.y*C/2,B=new $({xmin:u.x-q,xmax:u.x+q,ymin:u.y-J,ymax:u.y+J,spatialReference:a}),P={interpolation:"nearest",multidimensionalDefinition:i,sliceId:e.sliceId},{pixelBlock:w}=yield W.fetchPixels(B,C,C,P),{pixelBlock:T}=yield this.fetchPixels(B,C,C,P);if(w==null)return{location:u,value:null};let z=Math.floor(C*C*.5),V=!w.mask||w.mask[z]?w.pixels.map(G=>G[z]):null,F;return T!=null&&(F=!T.mask||T.mask[z]?T.pixels.map(G=>G[z]):void 0),{location:u,value:V,processedValue:F,pyramidLevel:0}}if(!y){if(e.srcResolution)p=rt(e.srcResolution,h,this.ioConfig.sampling).pyramidLevel;else if(p=yield this.computeBestPyramidLevelForLocation(t,e),p==null)return{location:u,value:null}}let x=this.identifyPixelLocation(u,p,null,y);if(x===null)return{location:u,value:null};let{row:d,col:I,rowOffset:g,colOffset:R,blockWidth:L}=x,_=s??e.sliceId,H=st(this.rasterId,_),A=`${p}/${d}/${I}`,E=ot(H,null,A);E==null&&(E=this.fetchRawTile(p,d,I,e),lt(H,null,A,E));let M=yield E;if(!M?.pixels?.length)return{location:u,value:null};let U=g*L+R;return this._processIdentifyResult(M,{srcLocation:u,position:U,pyramidLevel:p,useTransposedTile:!!y,requestSomeSlices:r,identifyOptions:e})})}fetchPixels(l,h,f){return D(this,arguments,function*(t,e,n,i={}){t=Bt(t),i=this._getRequestOptionsWithSliceId(i);let{_hasNoneOrGCSShiftTransform:o}=this;if(i.requestRawData&&o)return this._fetchPixels(t,e,n,i);let s=X(t.spatialReference),r=tt(t);if(s==null||r===0||r===1&&this._isGlobalWrappableSource&&o)return this._fetchPixels(t,e,n,i);if(r>=3)return{extent:t,pixelBlock:null};let a=[],{xmin:c,xmax:m}=t,u=Math.round(s/(m-c)*e),p=u-Math.round((s/2-c)/(m-c)*e),y=0,x=[];for(let R=0;R<=r;R++){let L=new $({xmin:R===0?c:-s/2,xmax:R===r?m-s*R:s/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),_=R===0?u-p:R===r?e-y:u;y+=_,x.push(_);let H=i.disableWrapAround&&R>0?null:this._fetchPixels(L,_,n,i);a.push(H)}let d=(yield Promise.all(a)).map(R=>R?.pixelBlock),I=null,g={width:e,height:n};return this.rasterJobHandler?I=(yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:g,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:x},i)).pixelBlock:I=Y(d,g,{blockWidths:x}),{extent:t,srcExtent:Z(t,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:I}})}fetchRawPixels(l,h,f){return D(this,arguments,function*(t,e,n,i={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};let o=yield this._fetchRawTiles(t,e,n,i),{nativeExtent:s,nativePixelSize:r,storageInfo:a}=this.rasterInfo,c=2**t,m=r.x*c,u=r.y*c,p=new $({xmin:s.xmin+m*e.x,xmax:s.xmin+m*(e.x+n.width-1),ymin:s.ymax-u*(e.y+n.height-1),ymax:s.ymax-u*e.y,spatialReference:s.spatialReference});if(!o)return{extent:p,srcExtent:p,pixelBlock:null};let{pixelBlocks:y,mosaicSize:x}=o;if(y.length===1&&y[0]!=null&&y[0].width===n.width&&y[0].height===n.height)return{extent:p,srcExtent:p,pixelBlock:o.pixelBlocks[0]};let d=t>0?a.pyramidBlockWidth:a.blockWidth,I=t>0?a.pyramidBlockHeight:a.blockHeight,g={x:e.x%d,y:e.y%I},R;return this.rasterJobHandler?R=(yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:x,destDimension:n,clipOffset:g,clipSize:n,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:R=Y(y,x,{clipOffset:g,clipSize:n}),{extent:p,srcExtent:p,pixelBlock:R}})}fetchRawTile(t,e,n,i){throw new ft("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Z(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?wt(t,e):this.rasterJobHandler.decode({data:t,options:e})}request(t,e,n=0){return D(this,null,function*(){let{customFetchParameters:i}=this.ioConfig,{range:l,query:h,headers:f}=e;n=n??e.retryCount??this.ioConfig.retryCount;let o=l?{Range:`bytes=${l.from}-${l.to}`}:null;try{return yield yt(t,N(v({},e),{query:v(v({},h),i),headers:v(v({},f),o)}))}catch(s){if(n>0)return n--,this.request(t,e,n);throw s}})}getSliceIndex(t){let{multidimensionalInfo:e}=this.rasterInfo;return e==null||t==null||t.length===0?null:Lt(t,e)}getTileExtentFromTileInfo(t,e,n,i){let l=i.lodAt(t);return this.getTileExtent({x:l.resolution,y:l.resolution},e,n,i.origin,i.spatialReference,i.size)}updateTileInfo(){let{storageInfo:t,spatialReference:e,extent:n,pixelSize:i}=this.rasterInfo,{pyramidResolutions:l}=t;if(!t.tileInfo){let h=[],f=t.maximumPyramidLevel||0,o=(i.x+i.y)/2,s=1/.0254*96*o;for(let a=0;a<=f&&(h.unshift(new It({level:f-a,resolution:o,scale:s})),a!==f);a++)if(l){let c=(l[a].x+l[a].y)/2;s*=c/o,o=c}else o*=2,s*=2;let r=new O({x:n.xmin,y:n.ymax,spatialReference:e});t.tileInfo=new et({origin:r,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:h}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,n=512,i){let{width:l,height:h,nativeExtent:f,pixelSize:o,spatialReference:s}=t,r=new O({x:f.xmin,y:f.ymax,spatialReference:s});i==null&&(i=Math.max(0,Math.round(Math.log(Math.max(l,h))/Math.LN2-8)));let a=this.computeBlockBoundary(f,512,512,{x:f.xmin,y:f.ymax},[o],i);t.storageInfo=new Tt({blockWidth:e,blockHeight:n,pyramidBlockWidth:e,pyramidBlockHeight:n,origin:r,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:a})}computeBestPyramidLevelForLocation(n){return D(this,arguments,function*(t,e={}){return 0})}computeBlockBoundary(t,e,n,i,l,h=0,f=2){if(l.length===1&&h>0){l=[...l];let{x:a,y:c}=l[0];for(let m=0;m<h;m++)a*=f,c*=f,l.push({x:a,y:c})}let o=[],{x:s,y:r}=i;for(let a=0;a<l.length;a++){let{x:c,y:m}=l[a];o.push({minCol:Math.floor((t.xmin-s+.1*c)/e/c),maxCol:Math.floor((t.xmax-s-.1*c)/e/c),minRow:Math.floor((r-t.ymax+.1*m)/n/m),maxRow:Math.floor((r-t.ymin-.1*m)/n/m)})}return o}getPyramidPixelSize(t){let{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:n,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(t===0)return e;if(n!=null&&n.length)return n[t-1];let l=i**t;return{x:e.x*l,y:e.y*l}}identifyPixelLocation(t,e,n,i){let{spatialReference:l,nativeExtent:h,storageInfo:f}=this.rasterInfo,{maximumPyramidLevel:o,origin:s,transposeInfo:r}=f,a=i&&r!=null?r.tileSize[0]:f.blockWidth,c=i&&r!=null?r.tileSize[1]:f.blockHeight,m=nt(t,l,n);if(!h.intersects(m)||e<0||e>o)return null;let u=this.getPyramidPixelSize(e),{x:p,y}=u,x=(s.y-m.y)/y/c,d=(m.x-s.x)/p/a,I=Math.min(c-1,Math.floor((x-Math.floor(x))*c)),g=Math.min(a-1,Math.floor((d-Math.floor(d))*a));return{pyramidLevel:e,row:Math.floor(x),col:Math.floor(d),rowOffset:I,colOffset:g,blockWidth:a,srcLocation:m}}getTileExtent(t,e,n,i,l,h){let[f,o]=h,s=i.x+n*f*t.x,r=s+f*t.x,a=i.y-e*o*t.y,c=a-o*t.y;return new $({xmin:s,xmax:r,ymin:c,ymax:a,spatialReference:l})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,n){let i=this.rasterInfo.storageInfo.blockBoundary[t];return!i||i.maxRow<e||i.maxCol<n||i.minRow>e||i.minCol>n}updateImageSpaceRasterInfo(t){let{pixelSize:e}=t,{width:n,height:i}=t,l=gt.WebMercator;t.spatialReference=l,t.extent=t.nativeExtent=new $({xmin:-.5,ymax:.5,xmax:n-.5,ymin:.5-i,spatialReference:l}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new O({x:1,y:1,spatialReference:l});let{extent:h,storageInfo:f}=t;if(f){f.origin=new O({x:h.xmin,y:h.ymax,spatialReference:l});let{pyramidResolutions:o,tileInfo:s}=f;if(o&&o.forEach(r=>{r.x/=e.x,r.y/=e.y}),s){s.origin=f.origin;let r=(t.nativePixelSize.x+t.nativePixelSize.y)/2;s.lods.forEach((a,c)=>{a.resolution=r*2**c,a.scale=96*a.resolution/.0254})}}}_fetchPixels(l,h,f){return D(this,arguments,function*(t,e,n,i={}){let o=tt(t);if(o>=2)return{extent:t,pixelBlock:null};let s=this._getSourceDataInfo(t,e,n,i),{pyramidLevel:r,srcResolution:a,srcExtent:c,srcWidth:m,srcHeight:u,ul:p}=s;if(m===0||u===0)return{extent:t,srcExtent:c,pixelBlock:null};let{rasterInfo:y}=this,x=y.transform,d=x?.type==="gcs-shift",I=X(t.spatialReference)!=null;!d&&I||(o=tt(s.srcExtent,d));let g=yield this._fetchRawTiles(r,p,{width:m,height:u,wrapCount:o},i);if(!g)return{extent:t,srcExtent:c,pixelBlock:null};let R=y.storageInfo,L=r>0?R.pyramidBlockWidth:R.blockWidth,_=r>0?R.pyramidBlockHeight:R.blockHeight,{x:H,y:A}=y.pixelSize;if(r>0){let{pyramidResolutions:j,pyramidScalingFactor:Gt}=R;if(j!=null&&j[r-1])({x:H,y:A}=j[r-1]);else{let at=Gt**r;H*=at,A*=at}}let E=y.spatialReference,M=new O({x:H,y:A,spatialReference:E}),U=L===m&&_===u&&p.x%L==0&&p.y%_==0,W=new O({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/n,spatialReference:t.spatialReference}),Q=!t.spatialReference.equals(E),C=E.isGeographic?1e-9:1e-4,{datumTransformation:q}=i;if(!Q&&U&&g.pixelBlocks.length===1&&L===e&&_===n&&Jt(a,W,C))return{extent:t,srcExtent:c,srcTilePixelSize:M,pixelBlock:g.pixelBlocks[0]};let J=I&&X(c.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,B=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");B&&!this.rasterJobHandler&&(yield it());let P=this.rasterJobHandler?yield this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:W.toJSON(),datumTransformation:q,rasterTransform:x,hasWrapAround:o>0||J,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:B},i):Pt({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:W,datumTransformation:q,rasterTransform:x,hasWrapAround:o>0||J,isAdaptive:!1,includeGCSGrid:B}),w,T=!i.requestRawData,z={rows:P.spacing[0],cols:P.spacing[1]},V=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,g.extent.xmin):void 0,{pixelBlocks:F,mosaicSize:G,isPartiallyFilled:Ft}=g,K=null;if(this.rasterJobHandler)({pixelBlock:w,localNorthDirections:K}=yield this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:G,destDimension:T?{width:e,height:n}:null,coefs:T?P.coefficients:null,sampleSpacing:T?z:null,projectDirections:B,gcsGrid:B?P.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:i.interpolation,alignmentInfo:V,blockWidths:null},i));else{let j=Y(F,G,{alignmentInfo:V});w=T?kt(j,{width:e,height:n},P.coefficients,z,i.interpolation):j,B&&P.gcsGrid&&(K=St({width:e,height:n},P.gcsGrid),w=Mt(w,this.rasterInfo.dataType,K))}return i.requestRawData||B?{extent:t,srcExtent:c,srcTilePixelSize:M,pixelBlock:w,transformGrid:P,localNorthDirections:K,isPartiallyFilled:Ft}:{extent:t,srcExtent:c,srcTilePixelSize:M,pixelBlock:w}})}_fetchRawTiles(t,e,n,i){return D(this,null,function*(){let{origin:l,blockBoundary:h}=this.rasterInfo.storageInfo,{blockWidth:f,blockHeight:o}=this.getBlockWidthHeight(t),{x:s,y:r}=e,{width:a,height:c,wrapCount:m}=n,u=this._getRasterTileAlignmentInfo(t,0);i.buffer&&(s-=i.buffer.cols,r-=i.buffer.rows,a+=2*i.buffer.cols,c+=2*i.buffer.rows);let p=0,y=0,x=0;m&&u!=null&&({worldColumnCountFromOrigin:y,originColumnOffset:x,rightPadding:p}=u,y*u.blockWidth-p>=s+a&&(p=0));let d=Math.floor(s/f),I=Math.floor(r/o),g=Math.floor((s+a+p-1)/f),R=Math.floor((r+c+p-1)/o),L=h[t];if(!L)return null;let{minRow:_,minCol:H,maxCol:A,maxRow:E}=L;if(m===0&&(R<_||g<H||I>E||d>A))return null;let M=new Array,U=!1,W=this.ioConfig.allowPartialFill==null?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let w=I;w<=R;w++)for(let T=d;T<=g;T++){let z=T;if(!i.disableWrapAround&&m&&u!=null&&y<=T&&(z=T-y-x),w>=_&&z>=H&&E>=w&&A>=z){let V=this._tileFetchQueue.push({pyramidLevel:t,row:w,col:z,options:i},{signal:i.signal});W?M.push(new Promise(F=>{V.then(G=>F(G)).catch(()=>{U=!0,F(null)})})):M.push(V)}else M.push(Promise.resolve(null))}if(M.length===0)return null;let Q=yield Promise.all(M),C={height:(R-I+1)*o,width:(g-d+1)*f},{spatialReference:q}=this.rasterInfo,J=this.getPyramidPixelSize(t),{x:B,y:P}=J;return{extent:new $({xmin:l.x+d*f*B,xmax:l.x+(g+1)*f*B,ymin:l.y-(R+1)*o*P,ymax:l.y-I*o*P,spatialReference:q}),pixelBlocks:Q,mosaicSize:C,isPartiallyFilled:U}})}_fetchRawTile(t,e,n,i){let l=this.rasterInfo.storageInfo.blockBoundary[t];if(!l)return Promise.resolve(null);let{minRow:h,minCol:f,maxCol:o,maxRow:s}=l;if(e<h||n<f||e>s||n>o)return Promise.resolve(null);let r=st(this.rasterId,i.sliceId),a=`${t}/${e}/${n}`,c=ot(r,i.registryId,a);if(c==null){let m=new AbortController;c=this.fetchRawTile(t,e,n,N(v({},i),{signal:m.signal})),lt(r,i.registryId,a,c,m),c.catch(()=>At(r,i.registryId,a))}return i.signal&&mt(i,()=>{Dt(r,i.registryId,a)}),c}_computeMagDirValues(t){let{bandCount:e,dataType:n}=this.rasterInfo;if(!(e===2&&n==="vector-magdir"||n==="vector-uv")||t?.length!==2||!t[0]?.length)return null;let i=t[0].length;if(n==="vector-magdir"){let s=t[1].map(r=>(r+360)%360);return[t[0],s]}let[l,h]=t,f=[],o=[];for(let s=0;s<i;s++){let[r,a]=_t([l[s],h[s]]);f.push(r),o.push(a)}return[f,o]}_getRasterTileAlignmentInfo(t,e){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=bt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:v({startX:e,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform},this._rasterTileAlignmentInfo.pyramidsInfo[t])}_getSourceDataInfo(t,e,n,i={}){let l={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};i.srcResolution&&(l.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,l));let h=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:f,srcHeight:o,pyramidLevel:s}=l,r=f/e,a=o/n,c=s<h&&r*a>=16,m=s===h&&this._requireTooManySrcTiles(f,o,e,n);if(c||m||f===0||o===0){let u=new O({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/n,spatialReference:t.spatialReference}),p=vt(u,this.rasterInfo.spatialReference,t,l.datumTransformation),y=!p||i.srcResolution&&p.x+p.y<i.srcResolution.x+i.srcResolution.y;if(c&&i.srcResolution&&y){let x=Math.round(Math.log(Math.max(r,a))/Math.LN2)-1;if(h-s+3>=x){let d=2**x;p={x:i.srcResolution.x*d,y:i.srcResolution.y*d}}}p&&(l.srcResolution=p,this._updateSourceDataInfo(t,l))}return this._requireTooManySrcTiles(l.srcWidth,l.srcHeight,e,n)&&(l.srcWidth=0,l.srcHeight=0),l}_requireTooManySrcTiles(t,e,n,i){let{tileInfo:l}=this.rasterInfo.storageInfo,h=Math.ceil(t/l.size[0])*Math.ceil(e/l.size[1]),f=t/n,o=e/i,s=Math.max(1,(n+i)/1024);return h>=Nt*s||f>Ot||o>Ot}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;let{rasterInfo:n}=this,i=n.spatialReference,{srcResolution:l,datumTransformation:h}=e,{pyramidLevel:f,pyramidResolution:o,excessiveReading:s}=rt(l,n,this.ioConfig.sampling);if(s)return;let r=e.srcExtent||Z(t,i,h);if(r==null)return;let a=n.transform;a&&(r=a.inverseTransform(r)),e.srcExtent=r;let{x:c,y:m}=n.storageInfo.origin,u=Math.floor((r.xmin-c)/o.x+.1),p=Math.floor((m-r.ymax)/o.y+.1),y=Math.floor((r.xmax-c)/o.x-.1),x=Math.floor((m-r.ymin)/o.y-.1),d=r.width<.1*o.x?0:y-u+1,I=r.height<.1*o.y?0:x-p+1;e.pyramidLevel=f,e.pyramidResolution=o,e.srcWidth=d,e.srcHeight=I,e.ul={x:u,y:p}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t=N(v({},t),{sliceId:this.getSliceIndex(t.multidimensionalDefinition)})),t}_processIdentifyResult(t,e){let{srcLocation:n,position:i,pyramidLevel:l,useTransposedTile:h}=e,f=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[i]))return{location:n,value:null};let{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!h){let x=t.pixels.map(g=>g[i]),d={location:n,value:x,pyramidLevel:l},I=this._computeMagDirValues(x.map(g=>[g]));return I?.length&&(d.magdirValue=I.map(g=>g[0])),d}let s=t.pixels.map(x=>x.slice(i*f,i*f+f)),r=this._computeMagDirValues(s),{requestSomeSlices:a,identifyOptions:c}=e,m=zt(o,c.transposedVariableName);if(a){let x=Ht(m,c.multidimensionalDefinition,c.timeExtent);s=s.map(d=>x.map(I=>d[I])),r=r?.map(d=>x.map(I=>d[I])),m=x.map(d=>m[d])}let u=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:s,pixelType:t.pixelType},y;return u!=null&&(Rt(p,u),y=p.mask),{location:n,value:null,dataSeries:m.map((x,d)=>{let I={value:y?.[d]===0?null:s.map(g=>g[d]),multidimensionalDefinition:x.multidimensionalDefinition.map(g=>new Ct(N(v({},g),{isSlice:!0})))};return r?.length&&(I.magdirValue=[r[0][d],r[1][d]]),I}),pyramidLevel:l}}};function Jt(t,e,n){return Math.abs(t.x-e.x)<n&&Math.abs(t.y-e.y)<n}k([b()],S.prototype,"_rasterTileAlignmentInfo",void 0),k([b()],S.prototype,"_tileFetchQueue",void 0),k([b({readOnly:!0})],S.prototype,"_isGlobalWrappableSource",null),k([b({readOnly:!0})],S.prototype,"_hasNoneOrGCSShiftTransform",null),k([b()],S.prototype,"_openPromise",void 0),k([b()],S.prototype,"rasterJobHandler",null),k([b({readOnly:!0})],S.prototype,"rasterId",null),k([b(Wt)],S.prototype,"url",null),k([b({type:String,json:{write:!0}})],S.prototype,"datasetName",void 0),k([b({type:String,json:{write:!0}})],S.prototype,"datasetFormat",void 0),k([b()],S.prototype,"hasUniqueSourceStorageInfo",void 0),k([b()],S.prototype,"rasterInfo",void 0),k([b()],S.prototype,"ioConfig",void 0),k([b()],S.prototype,"sourceJSON",void 0),S=k([ht("esri.layers.support.rasterDatasets.BaseRaster")],S);var Ie=S;export{Ie as a};
