import{c as B,d as E,e as F,g as L}from"./chunk-GYQWYHEG.js";import{b as q}from"./chunk-JC4DQSN3.js";import{h as x,j as T,k as V}from"./chunk-IO35PPBL.js";import{g as z,h as k}from"./chunk-F5AJITOA.js";import{b as i}from"./chunk-YOFFGXOB.js";import{a as g,c as m,f as p}from"./chunk-VTHXE323.js";var N=5;function j(e){return p(this,null,function*(){if(!e?.layer||!e.field&&!e.valueExpression)throw new i("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("class-breaks:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&q(e,"class-breaks");let v=e,{layer:l}=v,n=m(v,["layer"]),r=e.forBinning?E:B,s=L(l,r,e.forBinning);if(!s)throw new i("class-breaks:invalid-parameters","'layer' must be one of these types: "+F(r).join(", "));let a=g({layerAdapter:s},n);a.normalizationType=k(a),a.numClasses=a.numClasses||N;let D=a.signal!=null?{signal:a.signal}:null;yield s.load(D);let u=a.field,t=a.minValue,o=a.maxValue,C=t!=null||o!=null,f=a.classificationMethod,d=a.normalizationType==="percent-of-total",c=a.analyzeData!==!1,w=u?s.getField(u):null,A=yield z({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),y=V(s,A,"class-breaks:invalid-parameters");if(y)throw y;if(w){let b=x(s,w,"class-breaks:invalid-parameters");if(b)throw b}if(a.valueExpression&&a.normalizationType)throw new i("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");if(C)if(c){if(d&&a.normalizationTotal==null)throw new i("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified")}else{if(t==null||o==null)throw new i("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(t>=o)throw new i("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(f&&f!=="equal-interval")throw new i("class-breaks:invalid-parameters","'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(d&&a.normalizationTotal==null)throw new i("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false")}else if(!c)throw new i("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");a.filter&&!a.filter.spatialRelationship&&(a.filter.spatialRelationship="intersects");let h=T(a.filter,"class-breaks:invalid-parameters");if(h)throw h;return a})}function I(e){return p(this,null,function*(){let r=yield j(e),{layerAdapter:l}=r,n=m(r,["layerAdapter"]);return l.classBreaks(n)})}export{I as a};
