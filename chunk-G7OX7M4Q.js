import{a as Dt}from"./chunk-ZO3XNOAM.js";import{a as it,b as ft,c as Gt}from"./chunk-I46LG53M.js";import{Bb as b,Cb as F,Da as U,L as dt,N as gt,R as X,S as E,T as tt,Ya as xt,Za as yt,_a as Pt,ab as j,db as R,gb as St,ha as H,kb as et,v as pt,xb as T}from"./chunk-A2QQP5DF.js";import{a as J}from"./chunk-RRQS6PLL.js";import{O as _t,k as M}from"./chunk-WFHQTMIY.js";import{a as A}from"./chunk-XAZOVQGA.js";import{G as $,Ha as lt,a as Y,b as _,ga as ht,i as Q,k as Z,o as O,oa as z,ub as p,v as L}from"./chunk-V3KEO7AJ.js";import{d as I,e as B}from"./chunk-QGVBCWUY.js";function wt(){return new A}var ot=class{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(e,t,i){this.m_peR1=new T,this.m_peR2=new T,this.m_peR3=new T,e!==void 0?this.reset(e,t,i):this.reset(1,0,1)}reset(e,t,i){this.m_a=e,this.m_e2=t,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(e,t,i,s){let n=this.m_peR1,o=this.m_peR2,m=this.m_peR3;b.geodeticDistance(this.m_a,this.m_e2,e*this.m_unitToRad,t*this.m_unitToRad,i*this.m_unitToRad,s*this.m_unitToRad,m,n,o,0);let a=Math.cos(n.val),r=Math.cos(o.val+3.141592653589793),u=t*this.m_unitToRad,c=F.phiToEta(this.m_e2,u),h=Math.sin(n.val)*Math.cos(c),g=t;if(a*r<0){let D=a<0?-1:1,f=Math.acos(Math.abs(h))*D;g=F.etaToPhi(this.m_e2,f)/this.m_unitToRad}let d=ht((i-e)*this.m_unitToRad,2*Math.PI);Math.abs(d)>Math.PI&&(d=d>0?d-2*Math.PI:d+2*Math.PI),d/=this.m_unitToRad,i=e+d;let l=wt();return l.xmin=Math.min(e,i),l.xmax=Math.max(e,i),l.ymin=Math.min(t,s),l.ymin=Math.min(l.ymin,g),l.ymax=Math.max(t,s),l.ymax=Math.max(l.ymax,g),l}minDistanceGeodesic(e,t){let i=vt(e),s=vt(t);if(i&&s)return this.lowerDistanceGeodetic_(e.xmin,e.ymin,t.xmin,t.ymin);let n=this.normalizeGeodesic_(t,e);return Mt(e,n)?e.ymin>=n.ymax?this.minDistanceGeodesicUpDown_(e,n):n.ymin>=e.ymax?this.minDistanceGeodesicUpDown_(n,e):e.xmin>n.xmax?this.minDistanceGeodesicLeftRight_(n,e):this.minDistanceGeodesicLeftRight_(e,n):0}normalizeGeodesic_(e,t){let i=e.clone(),s=e.clone(),n=st(i,t);if(n===0)return i;for(;s.xmax>t.xmin;){s.xmin-=this.m_u360,s.xmax-=this.m_u360;let o=st(s,t);if(o<n&&(i.assign(s),n=o,n===0))return i}for(s.assign(e);s.xmin<t.xmax;){s.xmin+=this.m_u360,s.xmax+=this.m_u360;let o=st(s,t);if(o<n&&(i.assign(s),n=o,n===0))return i}return i}lowerDistanceGeodetic_(e,t,i,s){let n=this.m_peR1;{let o=this.m_b*this.m_b/this.m_a,m=F.phiToPhig(this.m_e2,this.m_unitToRad*t),a=F.phiToPhig(this.m_e2,this.m_unitToRad*s);b.geodeticDistance(o,0,this.m_unitToRad*e,m,this.m_unitToRad*i,a,n,null,null,0)}return n.val}minDistanceGeodesicUpDown_(e,t){if(t.xmin<=e.xmin?t.xmax>=e.xmin:e.xmax>=t.xmin)return this.lowerDistanceGeodetic_(0,e.ymin,0,t.ymax);if(t.xmin>e.xmax){let i=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);if(t.xmax-e.xmin<this.m_u180)return i;let s=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);return Math.min(i,s)}{let i=this.lowerDistanceGeodeticSegMeridional_(e.xmin,e.ymin,e.ymax,t.xmax,t.ymin,t.ymax);if(e.xmax-t.xmin<this.m_u180)return i;let s=this.lowerDistanceGeodeticSegMeridional_(e.xmax,e.ymin,e.ymax,t.xmin,t.ymin,t.ymax);return Math.min(i,s)}}minDistanceGeodesicLeftRight_(e,t){let i=Math.abs(e.xmax-t.xmin);for(;i>this.m_u180;)i-=this.m_u360;let s=Math.abs(e.xmin-t.xmax);for(;s>this.m_u180;)s-=this.m_u360;return Math.abs(i)<=Math.abs(s)?this.minDistanceGeodesicLeftRightNormalized_(e,t):this.minDistanceGeodesicLeftRightNormalized_(t,e)}minDistanceGeodesicLeftRightNormalized_(e,t){let i,s;return i=this.lowerDistanceGeodetic_(e.xmax,e.ymin,t.xmin,t.ymin),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymin,t.xmin,t.ymin,t.ymax),i=Math.min(i,s)),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymin,e.xmax,e.ymin,e.ymax),i=Math.min(i,s)),s=this.lowerDistanceGeodetic_(e.xmax,e.ymax,t.xmin,t.ymax),i=Math.min(i,s),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmax,e.ymax,t.xmin,t.ymin,t.ymax),i=Math.min(i,s)),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmin,t.ymax,e.xmax,e.ymin,e.ymax),i=Math.min(i,s)),i}lowerDistanceGeodeticSegMeridional_(e,t,i,s,n,o){let m=this.lowerDistanceGeodeticPtMeridional_(e,t,s,n,o),a=this.lowerDistanceGeodeticPtMeridional_(e,i,s,n,o),r=this.lowerDistanceGeodeticPtMeridional_(s,n,e,t,i),u=this.lowerDistanceGeodeticPtMeridional_(s,o,e,t,i);return m=Math.min(m,a),r=Math.min(r,u),Math.min(m,r)}lowerDistanceGeodeticPtMeridional_(e,t,i,s,n){let o=this.m_b*this.m_b/this.m_a,m=F.phiToPhig(this.m_e2,this.m_unitToRad*t),a=F.phiToPhig(this.m_e2,this.m_unitToRad*s),r=F.phiToPhig(this.m_e2,this.m_unitToRad*n),u=this.m_peR1,c=this.m_peR2;b.geodeticDistance(o,0,this.m_unitToRad*i,a,this.m_unitToRad*e,m,u,null,null,0),b.geodeticDistance(o,0,this.m_unitToRad*i,r,this.m_unitToRad*e,m,c,null,null,0);let h=E(1,0,new p(this.m_unitToRad*e,m)),g=E(1,0,new p(this.m_unitToRad*i,a)),d=E(1,0,new p(this.m_unitToRad*i,r)),l=new M;l.setCrossProductVector(g,d);let D=g.dotProduct(d);if(l.length()<1568e-13)return D>=0?Math.min(u.val,c.val):0;l=l.getUnitVector();let f=new M;if(f.setCrossProductVector(l,h),f.length()<1568e-13)return Math.min(u.val,c.val)-1e-5*o;f=f.getUnitVector();let x=h.sub(l.mul(h.dotProduct(l)));{let S=new M;S.setCrossProductVector(g,x);let v=new M;v.setCrossProductVector(x,d);let y=l.dotProduct(S)>0&&l.dotProduct(v)>0;if(y||(x.negateThis(),S.setCrossProductVector(g,x),v.setCrossProductVector(x,d),y=l.dotProduct(S)>0&&l.dotProduct(v)>0),y){x=x.getUnitVector();let V=tt(1,0,x),k=this.m_peR3;b.geodeticDistance(o,0,this.m_unitToRad*e,m,V.x,V.y,k,null,null,0);let q=Math.min(u.val,c.val);return Math.min(q,k.val)}}return Math.min(u.val,c.val)}};function vt(P){return P.xmin===P.xmax&&P.ymin===P.ymax}function Mt(P,e){return e.xmax<P.xmin||e.xmin>P.xmax||e.ymax<P.ymin||e.ymin>P.ymax}function st(P,e){let t,i=0;return t=P.xmin-e.xmax,t>i&&(i=t),t=e.xmin-P.xmax,t>i&&(i=t),i}var mt=class{};function Tt(P){return{outPoint:P===void 0?new p:P.clone()}}function W(P,e){P.outPoint.assign(e.outPoint)}function w(){return new A}var at=class{constructor(e,t,i,s,n=0,o=4){this.m_ptDistFrom=new p,this.m_segStartPt=new p,this.m_segEndPt=new p,this.m_geodeticLength=new T,this.m_az12=new T,this.m_minGeodeticDist=new T,this.m_segStartPt3d=new M,this.m_segEndPt3d=new M,this.m_sr=s,this.m_distCurveType=n,this.m_segCurveType=o,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();let m=et();this.m_inputGCS.querySpheroidData(m),this.m_a=m.majorSemiAxis,this.m_eSquared=m.e2,this.setPointDistFrom(e),this.setSegmentEndPoints(t,i)}setSegmentEndPoints(e,t){this.m_segStartPt.assign(e),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(E(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(E(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(e){this.m_ptDistFrom.assign(e),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(e){this.m_segCurveType=e}setDistanceCurveType(e){this.m_distCurveType=e}makeFunctor(){return e=>{let t;switch(this.m_segCurveType){case 0:case 1:case 3:{let i={stack:[],error:void 0,hasError:!1};try{let s=I(i,new T,!1),n=I(i,new T,!1);b.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*e,this.m_az12.val,s,n,this.m_segCurveType),t=new p(s.val,n.val);break}catch(s){i.error=s,i.hasError=!0}finally{B(i)}}case 2:{let i=M.lerp(this.m_segStartPt3d,this.m_segEndPt3d,e);t=tt(this.m_a,this.m_eSquared,i);break}case 4:t=p.lerp(this.m_segStartPt,this.m_segEndPt,e),this.m_bIsPannablePcs&&(R(this.m_sr,0,[t],1),t.mulThis(this.m_rpu));break;default:L("Invalid curve type")}return b.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,t.x,t.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:b.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=p.distance(this.m_segStartPt,this.m_segEndPt);break;default:L("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}};function nt(){return new mt}var bt=class{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(e,t,i,s,n){this.m_boxGeomA=w(),this.m_boxGeomB=w(),this.m_envGeomA=new A,this.m_envGeomB=new A,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new J,this.m_scaleToDegrees=new J,this.m_inputSR=e,this.m_distCurveType=t,this.m_progressTracker=i,this.m_maxDistance=s,this.m_maxDeviation=n,this.m_inputGCS=e.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;let o=et();this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_eSquared=o.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new ot(this.m_a,this.m_eSquared,1),this.m_distCurveType===4&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=this.m_inputSR.getCoordinateSystemType()===2&&this.m_inputSR.isPannable()}progress(e=!1){}calculate(e,t,i,s){let n=Tt(),o=Tt();if(e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(e,t,n,o))return i&&W(i,n),s&&W(s,o),0;let m=this.prepareGeometry(e);if(m.isEmpty())return Number.NaN;let a=this.prepareGeometry(t);if(a.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(m,a);let r=this._ExecuteBruteForce(m,a,n,o);return r>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(n),W(i,n)),s&&(this.prepareOutput(o),W(s,o)),r)}createDistanceFunctor(e,t,i){let s=new at(e,t,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||this.m_inputSR.getCoordinateSystemType()===1||s.setSegmentCurveType(2),s}_NormalizeAndProject(e){if(this.m_inputSR.isPannable()&&(e=new U().foldInto360Range(e,this.m_inputSR)),this.m_inputSR.getCoordinateSystemType()===2){let t=St(this.m_inputSR,this.m_inputGCS,null);e=new U().execute(e,t,this.m_progressTracker)}return e}_ExecuteBruteForce(e,t,i,s){switch(e.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointGeometry(e,t,i,s);case _.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(e,t,i,s);case _.enumPolyline:case _.enumPolygon:case _.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(e,t,i,s);default:O("")}}calculateDistanceGeodeticPointGeometry(e,t,i,s){switch(t.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointPoint(e,t,i,s);case _.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,i,s);case _.enumPolyline:case _.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(e,t,i,s);default:O("")}}calculateDistanceGeodeticPointPoint(e,t,i,s){let n={stack:[],error:void 0,hasError:!1};try{let o=e.getXY();o.scale(this.m_rpu);let m=t.getXY();m.scale(this.m_rpu),i.outPoint.assign(o),s.outPoint.assign(m);let a=I(n,new T,!1);return b.geodeticDistance(this.m_a,this.m_eSquared,o.x,o.y,m.x,m.y,a,null,null,this.m_distCurveType),a.val}catch(o){n.error=o,n.hasError=!0}finally{B(n)}}calculateDistanceGeodeticPointMultipoint(e,t,i,s){let n={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(e,t);let o=this.estimateMinimumDistance(i,s),m=o<this.m_maxDistance?o:this.m_maxDistance,a=e.getXY();a.scale(this.m_rpu),i.outPoint.assign(a);let r=E(this.m_a,this.m_eSquared,a),u=new p,c=t.getImpl(),h=I(n,new T,!1),g=c.getPointCount();for(let d=0;d<g;++d){c.queryXY(d,u),u.scale(this.m_rpu);let l=E(this.m_a,this.m_eSquared,u);if(!(M.distance(r,l)>m)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>m)&&(b.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,u.x,u.y,h,null,null,this.m_distCurveType),h.val<m&&(m=h.val,s.outPoint=u,m===0)))return m}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(o){n.error=o,n.hasError=!0}finally{B(n)}}calculateDistanceGeodeticPointMultipath(e,t,i,s){let n={stack:[],error:void 0,hasError:!1};try{let o=new p,m=new p;o.assign(e.getXY()),m.assign(e.getXY()),i.outPoint.assign(m.mul(this.m_rpu)),this.m_bIsPannablePcs&&j(this.m_inputSR,[o],1,!1),this.computeEnvelopesAndBoxes(e,t);let a=this.estimateMinimumDistance(i,s),r=a<this.m_maxDistance?a:this.m_maxDistance,u=t.getImpl(),c=new p(0,0),h=new p(0,0),g=[1],d=this.canUseSpatialTree(e,t),l=nt();d&&this.buildSpatialTree(l,t);let D=w();D.setCoords({xmin:m.x,ymin:m.y,xmax:m.x,ymax:m.y});let f=I(n,this.createDistanceFunctor(m,c,h),!1),x=u.querySegmentIterator();if(x.stripAttributes(),d)Y(0);else for(;x.nextPath();)for(;x.hasNextSegment();){let S=x.nextSegment(),v=this.findOrComputeBoxSegment(x.getStartPointIndex(),S,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(D,v)>r)continue;let y=this.calculateDistanceGeodeticPointSegment(o,m,S,g,f);if(y.second<r&&(this.updateOutputSegment(s,S,y.first),r=y.second,r===0))return 0}return r===this.m_maxDistance?Number.POSITIVE_INFINITY:r}catch(o){n.error=o,n.hasError=!0}finally{B(n)}}calculateDistanceGeodeticMultipointGeometry(e,t,i,s){switch(t.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,s,i);case _.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(e,t,i,s);case _.enumPolyline:case _.enumPolygon:case _.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(e,t,i,s);default:O("")}}calculateDistanceGeodeticMultipointMultipoint(e,t,i,s){let n={stack:[],error:void 0,hasError:!1};try{let o=I(n,new T,!1);this.computeEnvelopesAndBoxes(e,t);let m=this.estimateMinimumDistance(i,s),a=m<this.m_maxDistance?m:this.m_maxDistance,r=new p,u=new p,c=e.getImpl(),h=t.getImpl(),g=w(),d=c.getPointCount(),l=h.getPointCount();for(let D=0;D<d;++D){if(r.assign(c.getXY(D)),g.setCoords({xmin:r.x,ymin:r.y,xmax:r.x,ymax:r.y}),this.m_envHelper.minDistanceGeodesic(g,this.m_boxGeomB)>a)continue;r.scale(this.m_rpu);let f=E(this.m_a,this.m_eSquared,r);for(let x=0;x<l;++x){u.assign(h.getXY(x)),u.scale(this.m_rpu);let S=E(this.m_a,this.m_eSquared,u);if(!(M.distance(f,S)>=a)&&(b.geodeticDistance(this.m_a,this.m_eSquared,r.x,r.y,u.x,u.y,o,null,null,this.m_distCurveType),o.val<a&&(i.outPoint.assign(r),s.outPoint.assign(u),a=o.val,a===0)))return a}}return a===this.m_maxDistance?Number.POSITIVE_INFINITY:a}catch(o){n.error=o,n.hasError=!0}finally{B(n)}}calculateDistanceGeodeticMultipointMultipath(e,t,i,s){let n={stack:[],error:void 0,hasError:!1};try{let o=t.getImpl().querySegmentIterator();o.stripAttributes(),this.computeEnvelopesAndBoxes(e,t);let m=this.estimateMinimumDistance(i,s),a=m<this.m_maxDistance?m:this.m_maxDistance,r=new p,u=new p(0,0),c=new p(0,0),h=new p(0,0),g=[0],d=w(),l=I(n,this.createDistanceFunctor(u,c,h),!1),D=nt(),f=this.canUseSpatialTree(e,t);f&&this.buildSpatialTree(D,t);let x=e.getPointCount();for(let S=0;S<x;++S)if(r.assign(e.getXY(S)),u.assign(e.getXY(S)),this.m_bIsPannablePcs&&j(this.m_inputSR,[r],1,!1),d.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),!(this.m_envHelper.minDistanceGeodesic(d,this.m_boxGeomB)>a))if(l.setPointDistFrom(u),f)Y(0);else{for(;o.nextPath();)for(;o.hasNextSegment();){let v=o.nextSegment();if(this.m_envHelper.minDistanceGeodesic(d,this.findOrComputeBoxSegment(o.getStartPointIndex(),v,this.m_segmentBoxesB))>a)continue;let y=this.calculateDistanceGeodeticPointSegment(r,u,v,g,l);if(y.second<a&&(i.outPoint.assign(u.mul(this.m_rpu)),this.updateOutputSegment(s,v,y.first),a=y.second,a===0))return 0}o.resetToFirstPath()}return a===this.m_maxDistance?Number.POSITIVE_INFINITY:a}catch(o){n.error=o,n.hasError=!0}finally{B(n)}}calculateDistanceGeodeticMultipathGeometry(e,t,i,s){switch(t.getGeometryType()){case _.enumPoint:return this.calculateDistanceGeodeticPointMultipath(t,e,s,i);case _.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(t,e,s,i);case _.enumPolyline:case _.enumPolygon:case _.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(e,t,i,s);default:O("")}}calculateDistanceGeodeticMultipathMultipath(e,t,i,s){let n=[e],o=[t],m=this.swapGeometries(n,o),a=n[0],r=o[0];this.computeEnvelopesAndBoxes(n[0],o[0]);let u=this.estimateMinimumDistance(i,s),c=this.calculateDistanceGeodeticMultipathMultipath_(a,r,i,s,u);return m&&(s.outPoint=z(i.outPoint,i.outPoint=s.outPoint)),c}calculateDistanceGeodeticMultipathMultipath_(e,t,i,s,n=Number.MAX_VALUE){let o={stack:[],error:void 0,hasError:!1};try{let m=n,a=new p(0,0),r=new p,u=new p(0,0),c=new p,h=new p(0,0),g=new p,d=new p,l=new p,D=[new p],f=[0],x=[0],S=w(),v=w(),y=I(o,this.createDistanceFunctor(h,a,u),!1),V=nt(),k=this.canUseSpatialTree(e,t);k&&this.buildSpatialTree(V,t);let q=t.querySegmentIterator();q.stripAttributes();let rt=new dt,ut=Gt(e);for(let K=0;K<ut.length;++K){let ct=ut[K];e.getSegmentBuffer(ct,rt,!0);let C=rt.get();if(S.assign(this.findOrComputeBoxSegment(ct,C,this.m_segmentBoxesA)),k)Y(0);else{if(h.assign(C.getStartXY()),g.assign(C.getStartXY()),d.assign(C.getEndXY()),l.assign(C.getEndXY()),this.m_bIsPannablePcs&&(R(this.m_inputSR,0,[g],1),R(this.m_inputSR,0,[l],1)),this.m_envHelper.minDistanceGeodesic(S,this.m_boxGeomB)>m)continue;for(;q.nextPath();){for(;q.hasNextSegment();){let N=q.nextSegment();if(a.assign(N.getStartXY()),r.assign(N.getStartXY()),u.assign(N.getEndXY()),c.assign(N.getEndXY()),C.intersect(N,D,f,x,this.m_tolerance))return this.updateOutputSegment(i,C,f[0]),this.updateOutputSegment(s,N,x[0]),0;if(this.m_bIsPannablePcs&&(R(this.m_inputSR,0,[r],1),R(this.m_inputSR,0,[c],1)),v.assign(this.findOrComputeBoxPoint(q.getStartPointIndex(),r,c,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(S,v)>m)continue;y.setSegmentEndPoints(a,u),y.setPointDistFrom(g);let G=X(y.makeFunctor(),0,1,1e-10);if(G.second<m&&(i.outPoint.assign(g.mul(this.m_rpu)),this.updateOutputSegment(s,N,G.first),m=G.second,m===0)||(y.setPointDistFrom(l),G=X(y.makeFunctor(),0,1,1e-10),G.second<m&&(i.outPoint.assign(l.mul(this.m_rpu)),this.updateOutputSegment(s,N,G.first),m=G.second,m===0))||(y.setSegmentEndPoints(h,d),y.setPointDistFrom(r),G=X(y.makeFunctor(),0,1,1e-10),G.second<m&&(this.updateOutputSegment(i,C,G.first),s.outPoint.assign(r.mul(this.m_rpu)),m=G.second,m===0))||(y.setPointDistFrom(c),G=X(y.makeFunctor(),0,1,1e-10),G.second<m&&(this.updateOutputSegment(i,C,G.first),s.outPoint.assign(c.mul(this.m_rpu)),m=G.second,m===0)))break}if(m===0)return 0}q.resetToFirstPath()}}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(m){o.error=m,o.hasError=!0}finally{B(o)}}calculateDistanceGeodeticPointSegment(e,t,i,s,n){let o=i.getStartXY(),m=i.getEndXY();return i.intersectPoint(e,s,this.m_tolerance)?lt(s[0],0):(n.setPointDistFrom(t),n.setSegmentEndPoints(o,m),X(n.makeFunctor(),0,1,1e-10))}prepareGeometry(e){let t=e.clone(),i=e.getGeometryType();if(i===_.enumPoint||i===_.enumMultiPoint)return this._NormalizeAndProject(t);if(i===_.enumEnvelope&&(t=this.envelopeToPolygon(t)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(t,4);if(this.m_inputSR.getCoordinateSystemType()===2){if(t=Pt(t,this.m_inputSR,0,null),t.isEmpty())return t;t=new Dt().execute(t,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);let o=this.m_inputSR.getSRToGCSTransform();return new U().execute(t,o,this.m_progressTracker)}let s=new A;t.queryLooseEnvelope(s);let n=this.m_inputSR.getPannableExtent();if(s.ymin<n.ymin||s.ymax>n.ymax){let o=new A(s.xmin-1,n.ymin,s.xmax+1,n.ymax);if(t=new gt().execute(t,o,this.m_inputSR,this.m_progressTracker),t.isEmpty())return t}return s.width()>2*n.width()&&(t=yt(t,-2*n.width(),2*n.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker)),t}prepareGeometryPannable(e,t){let i=new A;e.queryEnvelope(i);let s=this.m_inputSR.getPannableExtent();if(s.containsEnvelope(i))return e;let n=new $;s.queryIntervalX(n);let o=new $;return i.queryIntervalX(o),e=n.contains(o)?xt(e,this.m_inputSR):new U().foldInto360RangeGeodetic(e,this.m_inputSR,t)}prepareOutput(e){e.outPoint.scale(1/this.m_rpu),this.m_inputSR.getCoordinateSystemType()===2&&j(this.m_inputSR,[e.outPoint],1,!1)}updateOutputSegment(e,t,i){t.queryCoord2D(i,e.outPoint),this.m_bIsPannablePcs&&R(this.m_inputSR,0,[e.outPoint],1),e.outPoint.mulThis(this.m_rpu)}computeTolerance(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB);let i=new A(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),_t(null,i)}envelopeToPolygon(e){let t=new pt;return t.addEnvelope(e,!1),t}computeEnvelopesAndBoxes(e,t){e.queryEnvelope(this.m_envGeomA),t.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(e,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(t,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(e,t,i){switch(e.getGeometryType()){case _.enumPoint:return this.computeBoxPoint(e,t);case _.enumMultiPoint:return this.computeBoxMultiPoint(e,t);case _.enumPolyline:case _.enumPolygon:return this.computeBoxMultiPath(e,t,i);default:L("Invalid geometry type")}}computeBoxPoint(e,t){let i=e.getXY();t.length=0,t.push(i.mul(this.m_rpu));let s=w();return s.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),s}computeBoxMultiPoint(e,t){let i=!0;for(let n=0;n<e.getPointCount();++n){let o=e.getXY(n);if(i){t.length=0;for(let m=0;m<4;++m)t.push(o.clone());i=!1}o.x<t[0].x&&t[0].assign(o),o.y>t[1].y&&t[1].assign(o),o.x>t[2].x&&t[2].assign(o),o.y<t[3].y&&t[3].assign(o)}for(let n=0;n<t.length;++n)t[n].mulThis(this.m_rpu);let s=w();return e.queryEnvelope(s),s}computeBoxMultiPath(e,t,i){let s=!0,n=w();n.setEmpty();let o=e.querySegmentIterator();for(o.stripAttributes();o.nextPath();)for(;o.hasNextSegment();){let m=o.nextSegment(),a=m.getStartXY(),r=m.getEndXY();if(this.m_bIsPannablePcs&&(R(this.m_inputSR,0,[a],1),R(this.m_inputSR,0,[r],1)),s){for(let c=0;c<4;++c)t.push(a.clone());s=!1}a.x<t[0].x&&t[0].assign(a),a.y>t[1].y&&t[1].assign(a),a.x>t[2].x&&t[2].assign(a),a.y<t[3].y&&t[3].assign(a),r.x<t[0].x&&t[0].assign(r),r.y>t[1].y&&t[1].assign(r),r.x>t[2].x&&t[2].assign(r),r.y<t[3].y&&t[3].assign(r);let u=this.findOrComputeBoxPoint(o.getStartPointIndex(),a,r,i);n.mergeEnvelope2D(u)}for(let m=0;m<t.length;++m)t[m].mulThis(this.m_rpu);return n}findOrComputeBoxSegment(e,t,i){if(!i.has(e)){let s=w();if(t.queryEnvelope(s),this.m_bIsPannablePcs){let n=p.construct(s.xmin,s.ymin),o=p.construct(s.xmax,s.ymax);R(this.m_inputSR,0,[n],1),R(this.m_inputSR,0,[o],1),s=this.m_envHelper.calculateBbox(n.x,n.y,o.x,o.y)}return i.set(e,s),s}return i.get(e)}findOrComputeBoxPoint(e,t,i,s){if(!s.has(e)){let n=w();return n.setCoords({xmin:t.x,ymin:t.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(n=this.m_envHelper.calculateBbox(n.xmin,n.ymin,n.xmax,n.ymax)),s.set(e,n),n}return s.get(e)}estimateMinimumDistance(e,t){let i={stack:[],error:void 0,hasError:!1};try{let s=c=>E(this.m_a,this.m_eSquared,c),n=this.m_boundaryPtsA.map(s),o=this.m_boundaryPtsB.map(s),m=Number.MAX_VALUE,a=0,r=0;for(let c=0;c<n.length;++c)for(let h=0;h<o.length;++h){let g=M.distance(n[c],o[h]);g<m&&(m=g,a=c,r=h)}e.outPoint.assign(this.m_boundaryPtsA[a]),t.outPoint.assign(this.m_boundaryPtsB[r]);let u=I(i,new T,!1);return b.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[a].x,this.m_boundaryPtsA[a].y,this.m_boundaryPtsB[r].x,this.m_boundaryPtsB[r].y,u,null,null,this.m_distCurveType),u.val}catch(s){i.error=s,i.hasError=!0}finally{B(i)}}swapGeometries(e,t){return Z(e[0])>Z(t[0])&&(t[0]=z(e[0],e[0]=t[0]),this.m_envGeomB=z(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(e,t){return!1}checkGeometriesIntersect(e,t,i,s){let n=e.getGeometryType(),o=t.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(n===_.enumPoint&&t.getDimension()===2){let c=[0],h=[e.getXY()];if(H(t,h,1,this.m_tolerance,c),c[0]!==0)return i.outPoint.assign(h[0]),s.outPoint.assign(h[0]),!0}else if(o===_.enumPoint&&e.getDimension()===2){let c=[2],h=[t.getXY()];if(H(e,h,1,this.m_tolerance,c),c[0]!==0)return i.outPoint.assign(h[0]),s.outPoint.assign(h[0]),!0}if(n===_.enumMultiPoint&&t.getDimension()===2)return this.multipointIntersectsArea(e,t,i,s);if(o===_.enumMultiPoint&&e.getDimension()===2)return this.multipointIntersectsArea(t,e,s,i);let m,a,r=e,u=t;if(n===_.enumEnvelope&&(m=this.envelopeToPolygon(e),r=m,n=_.enumPolygon),o===_.enumEnvelope&&(a=this.envelopeToPolygon(t),u=a,o=_.enumPolygon),Q(n)&&Q(o)){let c=r.querySegmentIterator(),h=u.querySegmentIterator(),g=it(),d=it();if(ft(r,u,c,h,g,d))return i.outPoint.assign(g.outPoint),s.outPoint.assign(g.outPoint),!0}}return!1}multipointIntersectsArea(e,t,i,s){let n=e.getPointCount();for(let o=0;o<n;++o){let m=[2],a=e.getXY(o);if(H(t,[a],1,this.m_tolerance,m),m[0]!==0)return i.outPoint.assign(a),s.outPoint.assign(a),!0}return!1}getNearestNeighbourVisitor(e,t,i,s,n,o,m){return Y(0),{}}buildSpatialTree(e,t){Y(0)}};export{Tt as a,at as b,bt as c};
