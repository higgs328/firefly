import{a as k}from"./chunk-VANM5A4M.js";import{d as R,i as z}from"./chunk-VSD74FMI.js";import{k as h,l as H,m as _,n as g,o as d,p as D,v as y,z as F}from"./chunk-HM5RIVQC.js";import{a as G}from"./chunk-WGAOVKGR.js";import{e as O,y as B}from"./chunk-4PTIEWMT.js";import{b as m}from"./chunk-YOFFGXOB.js";import{g as b}from"./chunk-XRGPJ3QY.js";import{f as W}from"./chunk-VTHXE323.js";var U=class{constructor(t=0,e=t){this.width=t,this.height=e,this.target=_.TEXTURE_2D,this.pixelFormat=g.RGBA,this.dataType=D.UNSIGNED_BYTE,this.samplingMode=h.LINEAR,this.wrapMode=H.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.shouldCompress=!1,this.depth=1,this.isImmutable=!1}};function K(s){return s.width<=0||s.height<=0?0:Math.round(s.width*s.height*s.depth*(s.hasMipmap?4/3:1)*(s.internalFormat==null?4:z(s.internalFormat))*(s.target===_.TEXTURE_CUBE_MAP?6:1))}var Z=()=>b.getLogger("esri/views/webgl/textureUtils");function S(s){(s.width!=null&&s.width<0||s.height!=null&&s.height<0||s.depth!=null&&s.depth<0)&&Z().error("Negative dimension parameters are not allowed!")}function V(s){return s in d}function C(s){return s in F}function I(s){return s!=null&&"type"in s&&s.type==="compressed"}function st(s){return!!s.descriptor.internalFormat&&C(s.descriptor.internalFormat)}function J(s){return s!=null&&"byteLength"in s}function L(s){return s!=null&&!I(s)&&!J(s)}function w(s){return s===_.TEXTURE_3D||s===_.TEXTURE_2D_ARRAY}function v(s,t,e,r=1){let i=Math.max(t,e);return s===_.TEXTURE_3D&&(i=Math.max(i,r)),Math.floor(Math.log2(i))+1}function P(s){if(s.internalFormat!=null)return s.internalFormat===g.DEPTH_STENCIL?g.DEPTH24_STENCIL8:s.internalFormat;switch(s.dataType){case D.FLOAT:switch(s.pixelFormat){case g.RGBA:return d.RGBA32F;case g.RGB:return d.RGB32F;default:throw new m("Unable to derive format")}case D.UNSIGNED_BYTE:switch(s.pixelFormat){case g.RGBA:return d.RGBA8;case g.RGB:return d.RGB8}}return s.internalFormat=s.pixelFormat===g.DEPTH_STENCIL?g.DEPTH24_STENCIL8:s.pixelFormat}function Y(s){let t="width"in s?s.width:s.codedWidth,e="height"in s?s.height:s.codedHeight;return s instanceof HTMLVideoElement&&(t=s.videoWidth,e=s.videoHeight),{width:t,height:e,depth:1}}var N=class s extends U{constructor(t,e){switch(super(),this.context=t,Object.assign(this,e),this.internalFormat){case d.R16F:case d.R16I:case d.R16UI:case d.R32F:case d.R32I:case d.R32UI:case d.R8_SNORM:case d.R8:case d.R8I:case d.R8UI:this.pixelFormat=g.RED}}static validate(t,e){return new s(t,e)}};var A=()=>b.getLogger("esri/views/webgl/Texture"),j=class u{constructor(t,e=null,r=null){if(this.type=k.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,this._compressionAbortController=G(null),"context"in t)this._descriptor=t,r=e;else{let i=N.validate(t,e);if(!i)throw new m("Texture descriptor invalid");this._descriptor=i}this._descriptor.target===_.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return K(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}get isCompressing(){return this._compressionAbortController.value!==null}dispose(){this.abortCompression(),this._glName&&this._descriptor.context.instanceCounter.decrement(y.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(t,e){let r=this._descriptor;if(r.width!==t||r.height!==e){if(this._wasImmutablyAllocated)throw new m("Immutable textures can't be resized!");r.width=t,r.height=e,this._descriptor.target===_.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(t){this._descriptor.shouldCompress=t}setData(t){this.abortCompression(),!I(t)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in F&&(this._descriptor.internalFormat=void 0),this._setData(t),!I(t)&&this._descriptor.shouldCompress&&this._compressOnWorker(t)}updateData(t,e,r,i,n,a,l=0){a||A().error("An attempt to use uninitialized data!"),this._glName||A().error("An attempt to update uninitialized texture!");let o=this._descriptor;o.internalFormat=P(o);let{context:p,pixelFormat:c,dataType:T,target:x,isImmutable:E}=o;if(E&&!this._wasImmutablyAllocated)throw new m("Cannot update immutable texture before allocation!");let f=p.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES,!0);(e<0||r<0||e+i>o.width||r+n>o.height)&&A().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();let{gl:M}=p;l&&(i&&n||A().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),M.pixelStorei(M.UNPACK_SKIP_ROWS,l)),L(a)?M.texSubImage2D(x,t,e,r,i,n,c,T,a):I(a)?M.compressedTexSubImage2D(x,t,e,r,i,n,o.internalFormat,a.levels[t]):M.texSubImage2D(x,t,e,r,i,n,c,T,a),l&&M.pixelStorei(M.UNPACK_SKIP_ROWS,0),p.bindTexture(f,u.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,e,r,i,n,a,l,o){o||A().error("An attempt to use uninitialized data!"),this._glName||A().error("An attempt to update an uninitialized texture!");let p=this._descriptor;p.internalFormat=P(p);let{context:c,pixelFormat:T,dataType:x,isImmutable:E,target:f}=p;if(E&&!this._wasImmutablyAllocated)throw new m("Cannot update immutable texture before allocation!");w(f)||A().warn("Attempting to set 3D texture data on a non-3D texture");let M=c.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES);c.setActiveTexture(u.TEXTURE_UNIT_FOR_UPDATES),(e<0||r<0||i<0||e+n>p.width||r+a>p.height||i+l>p.depth)&&A().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();let{gl:X}=c;if(I(o))o=o.levels[t],X.compressedTexSubImage3D(f,t,e,r,i,n,a,l,p.internalFormat,o);else{let q=o;X.texSubImage3D(f,t,e,r,i,n,a,l,T,x,q)}c.bindTexture(M,u.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){let t=this._descriptor;if(t.width===0||t.height===0)return;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new m("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,S(t)}t.samplingMode===h.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=h.LINEAR_MIPMAP_NEAREST):t.samplingMode===h.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=h.NEAREST_MIPMAP_NEAREST);let e=this._descriptor.context.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(u.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(t.target),this._descriptor.context.bindTexture(e,u.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){let t=this._descriptor;if(t.hasMipmap){if(this._wasImmutablyAllocated)throw new m("Cannot delete mipmaps to immutable texture after allocation");t.hasMipmap=!1,this._samplingModeDirty=!0,S(t)}t.samplingMode===h.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,t.samplingMode=h.LINEAR):t.samplingMode===h.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=h.NEAREST)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,S(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1)}abortCompression(){this.isCompressing&&(this._compressionAbortController.value=O(this._compressionAbortController.value))}_setData(t,e){let r=this._descriptor,i=r.context?.gl;if(!i)return;R(i),this._glName||(this._glName=i.createTexture(),this._glName&&r.context.instanceCounter.increment(y.Texture,this)),S(r);let n=r.context.bindTexture(this,u.TEXTURE_UNIT_FOR_UPDATES);r.context.setActiveTexture(u.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),R(i);let a=e??r.target,l=w(a);if(L(t))this._setDataFromTexImageSource(t,a);else{let{width:o,height:p,depth:c}=r;if(o==null||p==null)throw new m("Width and height must be specified!");if(l&&c==null)throw new m("Depth must be specified!");if(r.internalFormat=P(r),r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,r.internalFormat,r.hasMipmap,o,p,c),I(t)){if(!C(r.internalFormat))throw new m("Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(t,r.internalFormat,a)}else this._texImage(a,0,r.internalFormat,o,p,c,t),R(i),r.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),R(i),r.context.bindTexture(n,u.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(t=null){for(let e=_.TEXTURE_CUBE_MAP_POSITIVE_X;e<=_.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}_configurePixelStorage(){let t=this._descriptor.context.gl,{unpackAlignment:e,flipped:r,preMultiplyAlpha:i}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_setDataFromTexImageSource(t,e){let{gl:r}=this._descriptor.context,i=this._descriptor;i.internalFormat=P(i);let n=w(e),{width:a,height:l,depth:o}=Y(t);i.width&&i.height,i.width||(i.width=a),i.height||(i.height=l),n&&i.depth,n&&(i.depth=o),i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,i.internalFormat,i.hasMipmap,a,l,o),this._texImage(e,0,i.internalFormat,a,l,o,t),R(r),i.hasMipmap&&(this.generateMipmap(),R(r))}_setDataFromCompressedSource(t,e,r){let i=this._descriptor,{width:n,height:a,depth:l}=i,o=t.levels,p=v(r,n,a,l),c=Math.min(p,o.length)-1;this._descriptor.context.gl.texParameteri(i.target,i.context.gl.TEXTURE_MAX_LEVEL,c),this._forEachMipmapLevel((T,x,E,f)=>{let M=o[Math.min(T,o.length-1)];this._compressedTexImage(r,T,e,x,E,f,M)},c)}_texStorage(t,e,r,i,n,a){let{gl:l}=this._descriptor.context;if(!V(e))throw new m("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;let o=r?v(t,i,n,a):1;if(w(t)){if(a==null)throw new m("Missing depth dimension for 3D texture upload");l.texStorage3D(t,o,e,i,n,a)}else l.texStorage2D(t,o,e,i,n);this._wasImmutablyAllocated=!0}_texImage(t,e,r,i,n,a,l){let o=this._descriptor.context.gl,p=w(t),{isImmutable:c,pixelFormat:T,dataType:x}=this._descriptor;if(c){if(l!=null){let E=l;if(p){if(a==null)throw new m("Missing depth dimension for 3D texture upload");o.texSubImage3D(t,e,0,0,0,i,n,a,T,x,E)}else o.texSubImage2D(t,e,0,0,i,n,T,x,E)}}else{let E=l;if(p){if(a==null)throw new m("Missing depth dimension for 3D texture upload");o.texImage3D(t,e,r,i,n,a,0,T,x,E)}else o.texImage2D(t,e,r,i,n,0,T,x,E)}}_compressedTexImage(t,e,r,i,n,a,l){let o=this._descriptor.context.gl,p=w(t);if(this._descriptor.isImmutable){if(l!=null)if(p){if(a==null)throw new m("Missing depth dimension for 3D texture upload");o.compressedTexSubImage3D(t,e,0,0,0,i,n,a,r,l)}else o.compressedTexSubImage2D(t,e,0,0,i,n,r,l)}else if(p){if(a==null)throw new m("Missing depth dimension for 3D texture upload");o.compressedTexImage3D(t,e,r,i,n,a,0,l)}else o.compressedTexImage2D(t,e,r,i,n,0,l)}_compressOnWorker(t){return W(this,null,function*(){if(!u.compressionWorkerHandle||!u.compressionWorkerHandle.isCompressible(t))return;let e=this._descriptor.context?.gl.getExtension("WEBGL_compressed_texture_etc"),r=this._descriptor.context?.gl.getExtension("WEBGL_compressed_texture_s3tc");if(e||r){let i=new AbortController;this._compressionAbortController.value=i;let n={data:yield createImageBitmap(t),flipped:this.descriptor.flipped,width:t.width,height:t.height,hasMipmap:this._descriptor.hasMipmap,hasETC:!!e,hasS3TC:!!r};u.compressionWorkerHandle.invoke(n,this._compressionAbortController.value.signal).then(a=>{a&&this.isCompressing&&this.glName&&(this._descriptor.internalFormat=a.internalFormat,this._setData(a.compressedTexture)),i===this._compressionAbortController.value&&(this._compressionAbortController.value=null)}).catch(a=>{B(a)||i!==this._compressionAbortController.value||(this._compressionAbortController.value=null)})}})}_forEachMipmapLevel(t,e=1/0){let{width:r,height:i,depth:n,hasMipmap:a,target:l}=this._descriptor,o=l===_.TEXTURE_3D;if(r==null||i==null||o&&n==null)throw new m("Missing texture dimensions for mipmap calculation");for(let p=0;t(p,r,i,n),a&&(r!==1||i!==1||o&&n!==1)&&!(p>=e);++p)r=Math.max(1,r>>1),i=Math.max(1,i>>1),o&&(n=Math.max(1,n>>1))}_applySamplingMode(){let t=this._descriptor,e=t.context?.gl,r=t.samplingMode,i=t.samplingMode;r===h.LINEAR_MIPMAP_NEAREST||r===h.LINEAR_MIPMAP_LINEAR?(r=h.LINEAR,t.hasMipmap||(i=h.LINEAR)):r!==h.NEAREST_MIPMAP_NEAREST&&r!==h.NEAREST_MIPMAP_LINEAR||(r=h.NEAREST,t.hasMipmap||(i=h.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,r),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,i)}_applyWrapMode(){let t=this._descriptor,e=t.context?.gl;typeof t.wrapMode=="number"?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}_applyAnisotropicFilteringParameters(){let t=this._descriptor,e=t.context.capabilities.textureFilterAnisotropic;e&&t.context.gl.texParameterf(t.target,e.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}};j.TEXTURE_UNIT_FOR_UPDATES=0,j.compressionWorkerHandle=null;export{U as a,st as b,N as c,j as d};
