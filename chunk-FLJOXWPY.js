import{a as x}from"./chunk-KGY4BCEM.js";import{a as fo,d as xo,f as yo}from"./chunk-HMOFKUIJ.js";import{a as go,b as i}from"./chunk-QAHTJVUZ.js";import{a as so}from"./chunk-ZVSQXQ5X.js";import{b as v}from"./chunk-2IWALBQY.js";import{a as M,e as io,f as ho}from"./chunk-K6RQLPKJ.js";import{a as ao}from"./chunk-7V6BRQYE.js";import{a as oo,e as $,f as R}from"./chunk-PORMJXR6.js";import{b as uo}from"./chunk-Y7XG5IWW.js";import{f as h,g as co}from"./chunk-JBAMJB5J.js";import{b as po}from"./chunk-VAOSSSLB.js";import{a as S}from"./chunk-CUV3BSEW.js";import{d as Y}from"./chunk-2UHZH5L3.js";import{b as f}from"./chunk-DQINVX66.js";import{a as V,b as Co}from"./chunk-FRN24G7D.js";import{a as L,b as I,c as no}from"./chunk-FGABE2LC.js";import{a as vo}from"./chunk-GSXOR3JU.js";import{a as F}from"./chunk-EM2AEAFS.js";import{a as ro}from"./chunk-YEPHAEAY.js";import{b as Z}from"./chunk-TK4PPGQL.js";import{a as eo}from"./chunk-ELCBU4NP.js";import{a as to}from"./chunk-VGAXEXH3.js";import{a as lo}from"./chunk-4LDVFWME.js";import{a as mo}from"./chunk-7G56KLCZ.js";import{a as O,d as X}from"./chunk-7KP7SKLW.js";import{a as K}from"./chunk-ESSDCWGF.js";import{b as u}from"./chunk-EDOVNTC7.js";import{a as d,h as T}from"./chunk-YEXMIDOT.js";import{a as Q}from"./chunk-MVDZB4AK.js";import{a as r,b as l}from"./chunk-47NSYSFY.js";import{a as J}from"./chunk-QXNVQZT7.js";import{a as W,g as b}from"./chunk-ONYJLWAD.js";import{a as k,b as q,c as G}from"./chunk-ARRCN5K3.js";import{a as t}from"./chunk-QGVBCWUY.js";var C;(function(o){o[o.None=0]="None",o[o.Transparent=1]="Transparent",o[o.Opaque=2]="Opaque",o[o.COUNT=3]="COUNT"})(C||(C={}));var g;(function(o){o[o.None=0]="None",o[o.NoOverlay=1]="NoOverlay",o[o.ColorOverlay=2]="ColorOverlay",o[o.ColorOverlayWithWater=3]="ColorOverlayWithWater",o[o.COUNT=4]="COUNT"})(g||(g={}));var a=class extends go{constructor(e,n){super(),this.spherical=e,this.doublePrecisionRequiresObfuscation=n,this.output=d.Color,this.textureCoordinateType=L.None,this.componentData=O.Uniform,this.cullFace=W.Back,this.vertexDiscardMode=C.None,this.doubleSidedMode=v.WindingOrder,this.alphaDiscardMode=b.Opaque,this.integratedMeshMode=g.None,this.oitPass=F.NONE,this.ellipsoidMode=x.Earth,this.pbrMode=h.Disabled,this.normalType=u.Attribute,this.emissionSource=V.None,this.hasVertexColors=!1,this.hasNormals=!1,this.shadeNormals=!0,this.hasSlicePlane=!1,this.hasColorTexture=!1,this.receiveAmbientOcclusion=!0,this.receiveShadows=!0,this.blendingEnabled=!0,this.screenSpaceReflections=!1,this.hasPolygonOffset=!1,this.hasMetallicRoughnessTexture=!1,this.hasOcclusionTexture=!1,this.hasNormalTexture=!1,this.hasOccludees=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.hasNormalTextureTransform=!1,this.cloudReflections=!0,this.snowCover=!1,this.objectAndLayerIdColor=!1,this.discardInvisibleFragments=!1,this.occlusionPass=!1,this.bindType=J.Draw,this.useCustomDTRExponentForWater=!1,this.hasVertexTangents=!1,this.highStepCount=!1,this.instancedDoublePrecision=!1,this.hasModelTransformation=!1,this.useFillLights=!0,this.objectAndLayerIdColorInstanced=!1,this.canHaveOverlay=!0}};t([i({count:d.COUNT})],a.prototype,"output",void 0),t([i({count:L.COUNT})],a.prototype,"textureCoordinateType",void 0),t([i({count:O.COUNT})],a.prototype,"componentData",void 0),t([i({count:W.COUNT})],a.prototype,"cullFace",void 0),t([i({count:C.COUNT})],a.prototype,"vertexDiscardMode",void 0),t([i({count:v.COUNT})],a.prototype,"doubleSidedMode",void 0),t([i({count:b.COUNT})],a.prototype,"alphaDiscardMode",void 0),t([i({count:g.COUNT})],a.prototype,"integratedMeshMode",void 0),t([i({count:F.COUNT})],a.prototype,"oitPass",void 0),t([i({count:x.COUNT})],a.prototype,"ellipsoidMode",void 0),t([i({count:h.COUNT})],a.prototype,"pbrMode",void 0),t([i({count:u.COUNT})],a.prototype,"normalType",void 0),t([i({count:V.COUNT})],a.prototype,"emissionSource",void 0),t([i()],a.prototype,"hasVertexColors",void 0),t([i()],a.prototype,"hasNormals",void 0),t([i()],a.prototype,"shadeNormals",void 0),t([i()],a.prototype,"hasSlicePlane",void 0),t([i()],a.prototype,"hasColorTexture",void 0),t([i()],a.prototype,"receiveAmbientOcclusion",void 0),t([i()],a.prototype,"receiveShadows",void 0),t([i()],a.prototype,"blendingEnabled",void 0),t([i()],a.prototype,"screenSpaceReflections",void 0),t([i()],a.prototype,"hasPolygonOffset",void 0),t([i()],a.prototype,"hasMetallicRoughnessTexture",void 0),t([i()],a.prototype,"hasOcclusionTexture",void 0),t([i()],a.prototype,"hasNormalTexture",void 0),t([i()],a.prototype,"hasOccludees",void 0),t([i()],a.prototype,"terrainDepthTest",void 0),t([i()],a.prototype,"cullAboveTerrain",void 0),t([i()],a.prototype,"hasNormalTextureTransform",void 0),t([i()],a.prototype,"cloudReflections",void 0),t([i()],a.prototype,"snowCover",void 0),t([i()],a.prototype,"objectAndLayerIdColor",void 0);function U(o,e){let n=o.fragment;switch(e.doubleSidedMode){case v.None:n.code.add(r`vec3 _adjustDoublesided(vec3 normal) {
return normal;
}`);break;case v.View:o.include(f,e),n.code.add(r`vec3 _adjustDoublesided(vec3 normal) {
return dot(normal, vPositionWorldCameraRelative) > 0.0 ? -normal : normal;
}`);break;case v.WindingOrder:n.code.add(r`vec3 _adjustDoublesided(vec3 normal) {
return gl_FrontFacing ? normal : -normal;
}`);break;default:e.doubleSidedMode;case v.COUNT:}switch(e.normalType){case u.Attribute:case u.Compressed:o.include(M,e),n.main.add(r`vec3 fragmentFaceNormal = _adjustDoublesided(normalize(vNormalWorld));
vec3 fragmentFaceNormalView = gl_FrontFacing ? normalize(vNormalView) : -normalize(vNormalView);`);break;case u.ScreenDerivative:o.include(f,e),n.main.add(r`vec3 fragmentFaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));
vec3 fragmentFaceNormalView = normalize(cross(dFdx(vPosition_view), dFdy(vPosition_view)));`);default:case u.COUNT:}e.shadeNormals?n.main.add(r`vec3 fragmentShadingNormal = fragmentFaceNormal;`):e.spherical?(o.include(f,e),n.main.add(r`vec3 fragmentShadingNormal = normalize(positionWorld());`)):n.main.add(r`vec3 fragmentShadingNormal = vec3(0.0, 0.0, 1.0);`)}function bo(o,e){o.include(S,e),o.fragment.include(ho);let n=o.fragment;n.uniforms.add(new K("baseColor",s=>s.baseColor)),n.uniforms.add(new ao("objectOpacity",s=>s.objectOpacity)),e.hasVertexColors?n.code.add(r`vec3 _baseColor() {
return baseColor.rgb * vColor.rgb;
}
float _baseOpacity() {
return baseColor.a * vColor.a;
}`):n.code.add(r`vec3 _baseColor() {
return baseColor.rgb;
}
float _baseOpacity() {
return baseColor.a;
}`),n.code.add(r`vec4 computeMaterialColor(vec4 textureColor, vec4 externalColor, int externalColorMixMode) {
vec3 baseColor = _baseColor();
float baseOpacity = _baseOpacity();
vec3 color = mixExternalColor(
baseColor,
textureColor.rgb,
externalColor.rgb,
externalColorMixMode
);
float opacity = objectOpacity * mixExternalOpacity(
baseOpacity,
textureColor.a,
externalColor.a,
externalColorMixMode
);
return vec4(color, opacity);
}`)}function To(o,e){let n=e.hasColorTexture&&(T(e.output)||e.alphaDiscardMode!==b.Opaque);n&&(o.include(no,e),o.fragment.uniforms.add(new Q("baseColorTexture",s=>s.texture))),o.fragment.code.add(r`
    vec4 readBaseColorTexture() {
      return ${n?"textureLookup(baseColorTexture, vuv0)":"vec4(1.0)"};
    }
  `)}function Ao(o){let e=new mo,{vertex:n,fragment:s}=e;e.include(f,o),e.include(M,o),e.include(S,o),e.include(I,o),e.include(Y,o),e.include(X,o),e.include(io,o),s.include(Z,o),e.include(To,o),e.include(vo,o);let{output:c,pbrMode:N,hasNormalTexture:D,snowCover:_,receiveShadows:P,spherical:m,ellipsoidMode:E}=o,j=N===h.Normal||N===h.Schematic;j&&(e.include(co,o),D&&e.include(so,o));let B=c===d.Shadow||c===d.ShadowHighlight||c===d.ShadowExcludeHighlight,Oo=B&&o.componentData===O.Varying,p=o.integratedMeshMode===g.ColorOverlay||o.integratedMeshMode===g.ColorOverlayWithWater;if(p){e.include(R,o),e.include(xo,o);let y=E===x.Earth,A=E===x.Earth,Po=y?k.radius:A?q.radius:G.radius;n.code.add(`
      ${l(m,`const float invRadius = ${r.float(1/Po)};`)}
      vec2 projectOverlay(vec3 pos) { return pos.xy ${l(m,"/ (1.0 + invRadius * pos.z);")}; }`)}let w=p&&T(c)&&N===h.WaterOnIntegratedMesh;w&&(e.varyings.add("tbnTangent","vec3"),e.varyings.add("tbnBiTangent","vec3"),e.varyings.add("groundNormal","vec3"));let No=o.vertexDiscardMode===C.None,wo=o.vertexDiscardMode===C.Opaque,Mo=1-1/255;if(n.main.add(r`
    bool castShadows;
    vec4 externalColor = forwardExternalColor(castShadows);
    ${l(Oo,"if(!castShadows) { gl_Position = vec4(vec3(1e38), 1.0); return; }")}

    ${l(!No,`{ if (externalColor.a ${wo?">":"<="} ${r.float(Mo)}) { gl_Position = vec4(vec3(1e38), 1.0); return; } }`)}

    ${l(c===d.ObjectAndLayerIdColor,"externalColor.a = 1.0;")}

    forwardPosition(readElevationOffset());
    forwardViewPosDepth(vPosition_view);
    forwardNormal();
    forwardTextureCoordinates();
    forwardVertexColor();
    forwardLinearDepth();
    forwardObjectAndLayerIdColor();
    ${l(w,m?r`
              groundNormal = normalize(positionWorld());
              tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
              tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:r`
              groundNormal = vec3(0.0, 0.0, 1.0);
              tbnTangent = vec3(1.0, 0.0, 0.0);
              tbnBiTangent = vec3(0.0, 1.0, 0.0);`)}
    ${l(p,"setOverlayVTC(projectOverlay(position));")}

    if (externalColor.a < ${r.float(to)}) {
      // Discard this vertex
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    }
  `),T(c))return e.include(bo,o),e.include(U,o),e.include(R,o),e.include(Co,o),P&&e.include(uo,o),s.code.add(r`
      float evaluateShadow() {
        return ${P?"readShadowMap(vPositionWorldCameraRelative, linearDepth)":"0.0"};
      }`),p&&s.uniforms.add(new lo("ovColorTex",(y,A)=>yo(y,A))),s.main.add(r`
      discardBySlice(vPositionWorldCameraRelative);
      discardByTerrainDepth();

      vec4 textureColor = readBaseColorTexture();
      discardOrAdjustAlpha(textureColor);

      vec4 externalColor;
      int externalColorMixMode;
      readExternalColor(externalColor, externalColorMixMode);

      vec4 materialColor = computeMaterialColor(textureColor, externalColor, externalColorMixMode);
      ${l(p,r`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`)}
    `),j?(po(s),m&&$(s),s.main.add(r`
        applyPBRFactors();
        ${l(N===h.Normal,r`if (externalColorMixMode == 3) {
              mrr = vec3(0.0, 0.6, 0.2);
            }`)}
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
        ${l(D,"mat3 tangentSpace = computeTangentSpace(fragmentShadingNormal, vPositionWorldCameraRelative, vuv0);")}
        vec3 shadingNormal = ${D?"computeTextureNormal(tangentSpace, vuv0)":"fragmentShadingNormal"};
        vec3 normalGround = ${m?r`normalize(positionWorld())`:r`vec3(0.0, 0.0, 1.0)`};

        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * evaluateAmbientOcclusionInverse();
        ${l(_,r`float snow = smoothstep(0.5, 0.55, dot(fragmentFaceNormal, normalize(positionWorld())));
                 materialColor.rgb = mix(materialColor.rgb, vec3(1.1), snow);
                 ssao = mix(ssao, 0.5 * ssao, snow);
                 shadingNormal = mix(shadingNormal, fragmentFaceNormal, snow);`)}
        ${l(p,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        vec4 emission = getEmissions();
        ${l(m,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        ${m?r`float shadow = max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow());`:"float shadow = evaluateShadow();"}
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, shadow, ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);
        `)):(m&&$(s),w&&s.uniforms.add(new eo("ovNormalTex",y=>y.overlay?.getTexture(fo.WaterNormal))),s.main.add(r`
        ${l(m,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        float shadow = ${P?m?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow())":"evaluateShadow()":m?"lightingGlobalFactor * (1.0 - additionalAmbientScale)":"0.0"};

        ${l(_,r`float snow = smoothstep(0.5, 0.55, dot(fragmentFaceNormal, normalize(positionWorld())));
               materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)}

        // At global scale we create some additional ambient light based on the main light to simulate global illumination
        float ssao = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());

        ${l(p,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec4 shadedColor = vec4(evaluateSceneLighting(fragmentShadingNormal, materialColor.rgb, shadow, ssao, additionalLight), materialColor.a);
        ${l(w,r`vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
                 float waterNormalLength = length(overlayWaterMask);
                 if (waterNormalLength > 0.95) {
                   mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                   vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                   vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                   // un-gamma the ground color to mix in linear space
                   shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
                 }`)}
      `)),s.main.add("outputColorHighlightOID(shadedColor, vPositionWorldCameraRelative);"),e;let z=c===d.Normal,So=c===d.ObjectAndLayerIdColor,Do=c===d.Highlight,H=B||c===d.ViewshedShadow;return H&&e.include(oo,o),z&&e.include(U,o),e.include(ro,o),s.main.add(r`
    discardBySlice(vPositionWorldCameraRelative);

    vec4 textureColor = readBaseColorTexture();
    discardOrAdjustAlpha(textureColor);

    ${l(H,"outputDepth(linearDepth);")}
    ${l(z,r`fragColor = vec4(vec3(0.5) + 0.5 * fragmentFaceNormalView, 1.0);`)}
    ${l(So,p?"fragColor = getOverlayColorTexel();":"outputObjectAndLayerIdColor();")}
    ${l(Do,r`${l(p,r`
           vec2 overlayHighlightTexel = getAllOverlayHighlightValuesEncoded();
           calculateOcclusionAndOutputHighlightOverlay(overlayHighlightTexel);`,r`calculateOcclusionAndOutputHighlight();`)}`)}`),e}var qe=Object.freeze(Object.defineProperty({__proto__:null,build:Ao},Symbol.toStringTag,{value:"Module"}));export{C as a,g as b,a as c,Ao as d,qe as e};
