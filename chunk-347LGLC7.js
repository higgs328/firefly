import{a as V,b as q,m as O}from"./chunk-FKASYKK7.js";import"./chunk-LAAJ7BOG.js";import{c as st,d as nt,e as ot,v as y}from"./chunk-A2QQP5DF.js";import{a as K,c as Q}from"./chunk-LTHAIW3V.js";import"./chunk-RRQS6PLL.js";import"./chunk-WFHQTMIY.js";import"./chunk-XAZOVQGA.js";import{Ea as et,Ha as I,Ta as it,a as N,b as W,h as $,o as _,oa as F,pa as tt,ua as G,ub as x,y as v,z as A,za as C}from"./chunk-V3KEO7AJ.js";import"./chunk-MDZTV2VL.js";import"./chunk-RNC4P66O.js";import"./chunk-7LHOQXZT.js";import"./chunk-BCREO4Q5.js";import"./chunk-U4QEPZJ3.js";import"./chunk-KJUZWSCL.js";import"./chunk-3WO6D7MU.js";import"./chunk-BUZ3SPLE.js";import"./chunk-KVM6SHDX.js";import"./chunk-EQZWYK27.js";import"./chunk-ZQIC5NFT.js";import"./chunk-VIEK2X23.js";import"./chunk-XKIFGPJO.js";import"./chunk-PEW2PLAN.js";import"./chunk-Q6Y4JG7Q.js";import"./chunk-7F5DJLJT.js";import"./chunk-CX5IFQZJ.js";import"./chunk-NJWTSROP.js";import"./chunk-D3R25AF2.js";import"./chunk-ARRCN5K3.js";import"./chunk-G4DZJMGT.js";import"./chunk-X2B63YVS.js";import"./chunk-BAEF3CT6.js";import"./chunk-AUAZP44J.js";import"./chunk-PVDFCTA4.js";import"./chunk-KNVXE32P.js";import"./chunk-76ATOSLU.js";import"./chunk-CCJU4DSH.js";import"./chunk-QGVBCWUY.js";import"./chunk-MYO4NP2N.js";import"./chunk-NFIPKH6V.js";import"./chunk-JPU2PQZC.js";import"./chunk-5QEXLALV.js";import"./chunk-P6QFA5MM.js";import"./chunk-DGTD7Y73.js";import"./chunk-LI2SX4T6.js";import"./chunk-BWO7LS2H.js";import"./chunk-HEVQSRJ2.js";import"./chunk-OVHPPCBL.js";import"./chunk-SNFOAZZQ.js";import"./chunk-AML4XSEF.js";import"./chunk-4PTIEWMT.js";import"./chunk-TG2UTNEO.js";import"./chunk-YOFFGXOB.js";import"./chunk-XRGPJ3QY.js";import"./chunk-6MRUJ2UW.js";import"./chunk-2LI2GKBQ.js";import"./chunk-QBWJMFH5.js";import{a as T}from"./chunk-VTHXE323.js";function rt(c,t,i,e,s,n){let o=e-t;if(o<=n)return st(c,t,i,e,s),i;let h=ut(c,t,e,s,Math.min(Math.max(o>>1,3),100)),r=c[h];c[t]=F(c[h],c[h]=c[t]);let d=t+1,g=!1;for(let a=t+1;a!==e;++a)s(c[a],r)&&(c[d]=F(c[a],c[a]=c[d]),++d,g=!0);if(!g)for(let a=t+1;a<i;++a)s(r,c[a])||(a!==d&&(c[d]=F(c[a],c[a]=c[d])),++d);return--d,c[d]=F(c[t],c[t]=c[d]),d}function lt(c,t,i){let e=Math.trunc(t/2),s=BigInt(e),n=BigInt(t);for(let h=0;h<i;++h)c.push(Number(s%n)),s=6364136223846793005n*s+1442695040888963407n&0x7fffffffffffffffn,s=BigInt.asUintN(64,s);tt(c);let o=G(c,(h,r)=>h===r);c.length=o}function ut(c,t,i,e,s){let n=[];lt(n,i-t,s);let o=[];for(let r=0,d=n.length;r<d;r++){let g=n[r];o.push(I(c[t+g],g))}let h=Math.trunc(o.length/2);return o.sort((r,d)=>e(r.first,d.first)?-1:1),t+o[h].second}function ht(){return{p:new x,userData:Number.NaN,edge:null}}var L=class{constructor(){this.info=0,this.mask=!1,this.p=null,this.a=[null,null],this.twin=null}nextFreeEdge(){return this.twin}setIndex(t){this.info=t,this.mask=!1}getIndex(){return this.info}setMask(){this.mask=!0}getMask(){return this.mask}};function p(c,t){return{first:c,second:t}}function b(c,t){c.first=t.first,c.second=t.second}function ft(){return this.i1-this.i0}function R(){return{i0:Number.NaN,i1:Number.NaN,nextFreeEdgeIndex:[-1],box:[p(null,null),p(null,null)],size:ft}}function mt(){return{k:0,pTask:null,pTask0:null,pTask1:null}}function Z(){return{p:[new x,new x],points:[null,null]}}function dt(){return{p:[null,null,null]}}var S=class c{constructor(){this.m_nextFreePairEdge=p(null,null),this.m_points=[],this.m_pointZero=null,this.m_edges=[],this.m_voronoiToEdge=[],this.m_nextFreeEdge=0}clear(){this.m_nextFreePairEdge=p(null,null),this.m_points.length=0,this.m_pointZero=null,this.m_edges.length=0,this.m_voronoiToEdge.length=0,this.m_nextFreeEdge=0}reservePoints(t){N(t>1)}prepare(t){{let i=ht();i.p.x=Number.POSITIVE_INFINITY,i.p.y=Number.POSITIVE_INFINITY,i.userData=t,this.m_points.push(i)}}addVertex(t,i){let e=ht();e.p.assign(t),e.userData=i,e.edge=null,this.m_points.push(e)}removeDuplicates(){let t=this.m_points.shift();this.m_points.sort((s,n)=>s.p.compareX(n.p));let i=G(this.m_points,(s,n)=>s.p.equals(n.p)),e=i!==this.m_points.length;return this.m_points.length=i,this.m_points.unshift(t),e}boundVoronoiCells(t,i){let e=this.m_points.length;if(e<2)return!1;let s=[this.m_points[1].p.clone(),this.m_points[1].p.clone()];for(let d=2;d<e;d++){let g=this.m_points[d].p;g.x<s[0].x&&(s[0].x=g.x),s[1].x<g.x&&(s[1].x=g.x),g.y<s[0].y&&(s[0].y=g.y),s[1].y<g.y&&(s[1].y=g.y)}let n=new x;n.x=.5*(s[0].x+s[1].x),n.y=.5*(s[0].y+s[1].y);let o=0;for(let d=1;d<e;d++){let g=this.m_points[d].p,a=x.sqrDistanceCoords(g.x,g.y,n.x,n.y);o<a&&(o=a)}let h=Math.sqrt(o),r=Math.max(h+2*t,1.5*h);{let d=.8660254037844386,g=.5,a=1,u=0;for(let f=0;f<12;f++){let E=new x;E.x=n.x+r*a,E.y=n.y+r*u,this.addVertex(E,i);let l=a*g+u*d;a=a*d-u*g,u=l}}return!0}construct(){let t=R();return!!this.constructTask(t)&&(this.solveTask(t),!0)}constructTask(t){if(this.m_pointZero=this.createZeroHandle(),N(this.m_pointZero!==void 0),this.m_points.length<3)return!1;let i=6*(this.m_points.length-2);this.m_edges=C(L,i);for(let e=0;e<i;e++)this.m_edges[e].setIndex(e);return t.i0=1,t.i1=this.m_points.length,t.nextFreeEdgeIndex[0]=0,!0}splitTask(t,i,e,s){let n=t,o=i,h=e,r=s;n.k=this.findMaxSide(r.i0,r.i1);let d=r.i0+r.i1>>1,g=1250;n.k===0?d=rt(this.m_points,r.i0,d,r.i1,(a,u)=>a.p[0]!==u.p[0]?a.p[0]<u.p[0]:a.p[1]<u.p[1],g):d=rt(this.m_points,r.i0,d,r.i1,(a,u)=>a.p[1]!==u.p[1]?a.p[1]<u.p[1]:a.p[0]<u.p[0],g),o.i0=r.i0,o.i1=d,o.nextFreeEdgeIndex[0]=r.nextFreeEdgeIndex[0],r.nextFreeEdgeIndex[0]+=6*(o.i1-o.i0-1)+2,h.i0=d,h.i1=r.i1,h.nextFreeEdgeIndex[0]=r.nextFreeEdgeIndex[0],r.nextFreeEdgeIndex[0]+=6*(h.i1-h.i0-1)+2,n.pTask=r,n.pTask0=o,n.pTask1=h}solveMergeTask(t){let i=this.newPairEdgeEx(t.pTask.nextFreeEdgeIndex,!1);if(t.pTask.box[t.k]=p(t.pTask0.box[t.k].first,t.pTask1.box[t.k].second),t.pTask.box[1-t.k]=p(z(this.getPointXYFromEdge(t.pTask0.box[1-t.k].first),this.getPointXYFromEdge(t.pTask1.box[1-t.k].first),1-t.k)?t.pTask0.box[1-t.k].first:t.pTask1.box[1-t.k].first,z(this.getPointXYFromEdge(t.pTask0.box[1-t.k].second),this.getPointXYFromEdge(t.pTask1.box[1-t.k].second),1-t.k)?t.pTask1.box[1-t.k].second:t.pTask0.box[1-t.k].second),t.pTask.i0+2===t.pTask.i1){let n=t.pTask0.box[t.k].second,o=n.twin,h=t.pTask1.box[t.k].first,r=h.twin;return this.joinEdges2(o,r),this.joinEdges2(r,o),void this.join(n,h,0,1,i)}let e=[new Array(2),new Array(2)];e[0][0]=e[1][0]=p(t.pTask0.box[t.k].second,t.pTask0.box[t.k].second.twin),e[0][1]=e[1][1]=p(t.pTask1.box[t.k].first,t.pTask1.box[t.k].first.twin);let s=[!1,!1];if(t.pTask0.i0+1===t.pTask0.i1?(this.findEdgeSide(e[0],s,1,0),this.findEdgeSide(e[1],s,1,1)):(this.findEdge(e[0],s,0),this.findEdge(e[1],s,1)),s[0]||s[1]){if(s[0]){let n=this.newPairEdgeEx(t.pTask0.nextFreeEdgeIndex,!1);this.insertEdge(e[0][0].first,n.first,0),this.insertEdge(e[0][0].second,n.second,1)}if(s[1]){let n=this.newPairEdgeEx(t.pTask1.nextFreeEdgeIndex,!1);this.insertEdge(e[0][1].first,n.first,1),this.insertEdge(e[0][1].second,n.second,0)}}else this.getNextDEdge(e[0][0].first,0)!==e[0][0].first&&(e[1][0]=this.newPairEdgeEx(t.pTask0.nextFreeEdgeIndex,!1),this.insertEdge(e[0][0].first,e[1][0].first,0),this.insertEdge(e[0][0].second,e[1][0].second,1)),this.getNextDEdge(e[0][1].first,0)!==e[0][1].first&&(e[1][1]=this.newPairEdgeEx(t.pTask1.nextFreeEdgeIndex,!1),this.insertEdge(e[0][1].first,e[1][1].first,1),this.insertEdge(e[0][1].second,e[1][1].second,0));this.merge(e[1][0],e[0][0],e[0][1],e[1][1],i)}solveTask(t){let i=t;switch(i.i1-i.i0){case 1:{this.insertPoint(i.i0,i.nextFreeEdgeIndex);let e=this.m_points[i.i0].edge;i.box[0]=i.box[1]=I(e,e)}break;case 2:{let e=i.i0,s=e+1;this.insertPoint(e,i.nextFreeEdgeIndex),this.insertPoint(s,i.nextFreeEdgeIndex);let n=this.m_points[e],o=this.m_points[s],h=n.edge,r=o.edge,d=h.twin,g=r.twin;this.joinEdges2(d,g),this.joinEdges2(g,d);let a=this.newPairEdgeEx(i.nextFreeEdgeIndex,!1);this.join(h,r,0,1,a);for(let u=0;u<2;u++)i.box[u]=z(this.getPointXY(n),this.getPointXY(o),u)?p(h,r):p(r,h)}break;case 3:{let e=[i.i0,i.i0+1,i.i0+2];this.insertPoint(e[0],i.nextFreeEdgeIndex),this.insertPoint(e[1],i.nextFreeEdgeIndex),this.insertPoint(e[2],i.nextFreeEdgeIndex);let s=[this.m_points[e[0]],this.m_points[e[1]],this.m_points[e[2]]],n=this.caseFromCompare(s[0].p,s[1].p,s[2].p),o=[s[0].edge,s[1].edge,s[2].edge],h=c.c_aTableDelaunayTriangulationSolution[n],r=X(19*X(1+(7&h))),d=X(19*X(1+(h>>5))),g=X(h<<3)>>6,a=3&r,u=r>>6,f=3&d,E=d>>6;i.box[0]=p(o[a],o[u]),i.box[1]=p(o[f],o[E]);let l=[o[0].twin,o[1].twin,o[2].twin],m=[this.newPairEdgeEx(i.nextFreeEdgeIndex,!1),this.newPairEdgeEx(i.nextFreeEdgeIndex,!1),this.newPairEdgeEx(i.nextFreeEdgeIndex,!1)];switch(g===3&&(g=this.orientation(s[0].p,s[1].p,s[2].p)+1),g){case 0:this.joinEdges2(l[0],l[2]),this.joinEdges2(l[2],l[1]),this.joinEdges2(l[1],l[0]),this.join(o[0],o[2],0,1,m[0]),this.join(o[2],o[1],0,1,m[1]),this.join(o[1],o[0],0,1,m[2]);break;case 1:{let P=[0,1,2];P[3-(a+u)]=F(P[1],P[1]=P[3-(a+u)]),this.joinEdges2(l[P[0]],l[P[1]]),this.joinEdges2(l[P[1]],l[P[2]]),this.joinEdges2(l[P[2]],l[P[0]]),this.join(o[P[0]],o[P[1]],0,1,m[0]),this.join(o[P[1]],o[P[2]],0,1,m[1]),this.join(m[1].first,l[P[2]],0,1,m[2])}break;case 2:this.joinEdges2(l[0],l[1]),this.joinEdges2(l[1],l[2]),this.joinEdges2(l[2],l[0]),this.join(o[0],o[1],0,1,m[0]),this.join(o[1],o[2],0,1,m[1]),this.join(o[2],o[0],0,1,m[2])}}break;default:{let e=mt(),s=R(),n=R();this.splitTask(e,s,n,t),this.solveTask(s),this.solveTask(n),this.solveMergeTask(e)}}}getOutsideHull(){let t=[],i=this.m_points[0].edge,e=i;do t.push(this.getPointFromEdge(this.getTwinEdge(e))),e=this.getNextDEdge(e,0);while(e!==i);return t}getConvexHull(){let t=[],i=this.m_points[0].edge,e=i;do{let s=this.getPointFromEdge(this.getTwinEdge(e));t.length<2||!this.insideLine(this.getPointXY(t.at(-2)),this.getPointXY(t.at(-1)),this.getPointXY(s))?t.push(s):t[t.length-1]=s,e=this.getNextDEdge(e,0)}while(e!==i);return 2<t.length&&this.insideLine(this.getPointXY(t[0]),this.getPointXY(t.at(-1)),this.getPointXY(t.at(-2)))&&t.pop(),2<t.length&&this.insideLine(this.getPointXY(t[1]),this.getPointXY(t[0]),this.getPointXY(t.at(-1)))&&(t[0]=t.at(-1),t.pop()),t}getVoronoiPolygon(t,i){t.length=0;let e=this.getEdgeFromPoint(i),s=e;for(;;){let n=this.calculateCircleCenter(s);t.push(n);let o=this.getNextDEdge(s,1);if(o===e)break;s=o}}getNearestPoint(t){this.isInfinitePointFromPoint(t)&&_("Not supported for the infinite point");let i=this.getPointXY(t),e=this.m_pointZero,s=Number.MAX_VALUE,n=this.getEdgeFromPoint(t),o=n;do{let h=this.getPointFromEdge(this.getTwinEdge(o));if(!this.isInfinitePointFromPoint(h)){let r=x.sqrDistance(i,this.getPointXY(h));r<s&&(e=h,s=r)}o=this.getCounterClockwiseEdge(o)}while(o!==n);return e}addConstraint(t,i){let e=[null],s=[null];if(!this.constraintFindFirstEdge(e,s,t,i))return p(s[0],e[0]);e[0]=this.getTwinEdge(e[0]);let n=this.getPointXY(t),o=this.getPointXY(i),h=[new Array(0),new Array(0)],r=e[0];for(;;){let a=this.getClockwiseEdge(s[0]);a.getMask()&&_("add_constraint");let u=p(a,this.getTwinEdge(a));this.deleteTwinEdges(u,!0);let f=this.getCounterClockwiseEdge(this.getTwinEdge(e[0])),E=this.getTwinEdge(this.getClockwiseEdge(s[0])),l=this.getPointFromEdge(E);if(l===i){h[0].push(e[0]),e[0]=f,h[1].push(s[0]),s[0]=E;break}let m=this.orientation(n,o,this.getPointXY(l));m===0&&_("add_constraint - point on constraint"),0<m?(h[0].push(e[0]),e[0]=f):(h[1].push(s[0]),s[0]=E)}h[0].push(e[0]),h[1].push(s[0]);let d=this.newPairEdge();d.first.setMask(),d.second.setMask(),this.join(s[0],r,1,1,d),this.triangulateConstraint(h[0],1,h[0].length-1,d),h[1].reverse();let g=p(d.second,d.first);return this.triangulateConstraint(h[1],1,h[1].length-1,g),g}verify(){for(let t=0,i=this.m_edges.length;t<i;t++){let e=this.m_edges[t];if(!e.getMask()&&!this.testEdge(e))return!1}return!0}getDelaunayTriangleCount(){return this.m_points.length-2<<1}getVoronoiSegments(t=Number.MAX_VALUE){let i=[];for(let e=0,s=this.m_edges.length;e<s;e+=2){let n=p(null,null);if(n.first=this.m_edges[e],n.second=n.first.twin,this.isInfinitePointFromEdge(n.first)&&(n.second=F(n.first,n.first=n.second)),this.isInfinitePointFromEdge(n.second)){let o=C(x,3);o[0]=this.calculateCircleCenter(this.getNextDEdge(n.first,0).twin,1),o[2]=this.calculateCircleCenter(this.getNextDEdge(n.first,1),1);let h=C(x,2);h[0].assign(o[0]),h[1].assign(o[2]),h[0].rightPerpendicularThis(),h[1].leftPerpendicularThis(),o[1]=o[0].add(h[0]).add(o[2].add(h[1])),o[1].normalize();for(let d of o)d.mulThis(t);let r=Z();r.points[0]=n.first.p,r.points[1]=n.second.p;for(let d=0;d<o.length-1;d++){for(let g=0;g<2;g++)r.p[g]=o[d+g];r.p[0].equals(r.p[1])||i.push(r)}}else if(this.isInfinitePointFromEdge(this.getNextDEdge(n.first,0).twin)&&this.isInfinitePointFromEdge(this.getNextDEdge(n.first,1).twin)){let o=C(x,3);o[0]=this.calculateCircleCenter(n.first),o[1]=this.getPointXY(this.getPointFromEdge(n.first)).add(this.getPointXY(this.getPointFromEdge(n.second))).mul(.5),o[2]=this.calculateCircleCenter(n.second);let h=Z();h.points[0]=n.first.p,h.points[1]=n.second.p;for(let r=0;r<o.length-1;r++){for(let d=0;d<2;d++)h.p[d]=o[r+d];h.p[0].equals(h.p[1])||i.push(h)}}else{let o=Z();o.p[0]=this.calculateCircleCenter(n.first),o.p[1]=this.calculateCircleCenter(n.second),o.points[0]=n.first.p,o.points[1]=n.second.p,o.p[0].equals(o.p[1])||i.push(o)}}return i}startDelaunayTriangles(){return-1}nextDelaunayTriangle(t,i){for(;;){if(++i[0],i[0]===this.m_edges.length)return!1;let e=this.m_edges[i[0]];if(t.p[0]=this.getPointFromEdge(e),this.isInfinitePointFromPoint(t.p[0]))continue;let s=this.getTwinEdge(e);if(t.p[1]=this.getPointFromEdge(s),this.isInfinitePointFromPoint(t.p[1])||this.getPointXY(t.p[1]).lt(this.getPointXY(t.p[0])))continue;let n=this.getTwinEdge(this.getNextDEdge(e,1));if(t.p[2]=this.getPointFromEdge(n),!this.isInfinitePointFromPoint(t.p[2])&&!this.getPointXY(t.p[2]).lt(this.getPointXY(t.p[0])))return!0}}getPointCount(){return this.m_points.length-1}getPoint(t){return this.m_points[t+1]}getInfinitePoint(){return this.m_pointZero}isInfinitePointFromPoint(t){return t===this.m_pointZero}getPointXY(t){return t.p}getPointIndex(t){return t.userData}setPointIndex(t,i){t.userData=i}getEdgeFromPoint(t){return t.edge}isInfinitePointFromEdge(t){return t.p===this.m_pointZero}getEdgeCount(){return this.m_edges.length}getEdge(t){return this.m_edges[t]}getEdgeIndex(t){return t.getIndex()}getPointFromEdge(t){return t.p}getPointXYFromEdge(t){return t.p.p}getCounterClockwiseEdge(t){return t.a[0]}getClockwiseEdge(t){return t.a[1]}getTwinEdge(t){return t.twin}getPreviousEdge(t){return this.getTwinEdge(this.getCounterClockwiseEdge(t))}getNextEdge(t){return this.getClockwiseEdge(this.getTwinEdge(t))}getNextDEdge(t,i=1){return t.a[i]}newPairEdge(){let t=p(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second);return this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge(),t.first.twin=t.second,t.second.twin=t.first,t}newPairEdgeEx(t,i){let e;if(i&&this.m_nextFreePairEdge.first!==null)e=p(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second),this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge();else{let s=t[0]++,n=t[0]++;e=p(this.m_edges[s],this.m_edges[n])}return e.first.twin=e.second,e.second.twin=e.first,e}insertEdge(t,i,e){i.p=t.p;let s=t.a[e],n=i.a;n[e]=s,n[1-e]=t,t.a[e]=i,s.a[1-e]=i}insertPoint(t,i){let e=this.m_points[t],s=this.newPairEdgeEx(i,!1),n=s.first,o=s.second;e.edge=s.first,n.p=this.m_points[t],n.a[0]=s.first,n.a[1]=s.first,o.p=this.m_pointZero,o.a[0]=s.second,o.a[1]=s.second,this.m_points[0].edge===null&&(this.m_points[0].edge=s.second)}deleteTwinEdges(t,i){this.deleteEdge(t.first),this.deleteEdge(t.second),i&&(t.first.twin=this.m_nextFreePairEdge.first,t.second.twin=this.m_nextFreePairEdge.second,this.m_nextFreePairEdge=t)}join(t,i,e,s,n){this.insertEdge(t,n.first,e),this.insertEdge(i,n.second,s)}joinEdges2(t,i){t.a[1]=i,i.a[0]=t}checkEdge(t,i,e,s,n){for(;;){let o=p(null,null);if(o.first=this.getNextDEdge(t.first,s),o.second=o.first.twin,this.isInfinitePointFromEdge(o.second))return t;let h=this.getPointXYFromEdge(t.second),r=this.getPointXYFromEdge(o.second);if(this.inCircle(i,e,h,r)<=0)return t;if(this.deleteTwinEdges(t,n),!n){let d=this.getNextDEdge(t.second,s).twin;this.join(o.second,d,s,s,t)}t=o}}calculateCircleCenter(t,i=Number.MAX_VALUE){let e=this.getPointXYFromEdge(t),s=this.getPointXYFromEdge(t.twin),n=this.getNextDEdge(t,0);if(this.isInfinitePointFromEdge(n.twin)){let h=new x;if(Number.isNaN(i))h.setNAN();else{let r=s.sub(e);r.leftPerpendicularThis(),h.assign(r),h.divThis(Math.max(Math.abs(h.x),Math.abs(h.y))),h.normalize(),h.mulThis(i)}return h}let o=this.getPointXYFromEdge(n.twin);return this.calculateCircleCenterFromThreePoints(e,s,o)}createZeroHandle(){return this.m_points[0]}deleteEdge(t){let i=t,e=i.p;e.edge===t&&(e.edge=i.a[0]),i.a[0].a[1]=i.a[1],i.a[1].a[0]=i.a[0]}testEdge(t){if(this.isInfinitePointFromEdge(t))return!0;let i=t.twin;if(this.isInfinitePointFromEdge(i))return!0;let e=this.getNextDEdge(t,0).twin,s=this.getNextDEdge(i,0).twin;if(this.isInfinitePointFromEdge(e)||this.isInfinitePointFromEdge(s))return!0;let n=this.getPointXYFromEdge(t),o=this.getPointXYFromEdge(i),h=this.getPointXYFromEdge(e),r=this.getPointXYFromEdge(s);return!(this.orientation(n,o,h)<=0)&&!(0<=this.orientation(n,o,r))&&this.inCircle(n,o,h,r)<=0}findMaxSide(t,i){let e=[this.m_points[t].p.clone(),this.m_points[t].p.clone()];for(t++;t!==i;t++){let s=this.m_points[t].p;s.x<e[0].x&&(e[0].x=s.x),e[1].x<s.x&&(e[1].x=s.x),s.y<e[0].y&&(e[0].y=s.y),e[1].y<s.y&&(e[1].y=s.y)}return e[1].x-e[0].x<e[1].y-e[0].y?1:0}findEdge(t,i,e){let s=!1,n=0;for(;;){let o=p(null,null);if(o.second=this.getNextDEdge(t[n].second,e^n),o.first=o.second.twin,e===0&&this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(o.first))<0||e===1&&0<this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(o.first)))t[n]=o,i[n]=!0,s=!1;else{if(s)return;n^=1,s=!0}}}findEdgeSide(t,i,e,s){for(;;){let n=p(null,null);if(n.second=this.getNextDEdge(t[e].second,s^e),n.first=n.second.twin,!(s===0&&this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(n.first))<0||s===1&&0<this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(n.first))))return;t[e]=n,i[e]=!0}}merge(t,i,e,s,n){let o=T({},t),h=T({},s),r=T({},n),d=T({},i),g=T({},e),a=d.second,u=g.second;for(;;){if(this.join(d.first,g.first,0,1,r),d.first=this.getNextDEdge(r.first,0),g.first=this.getNextDEdge(r.second,1),d.first===o.first&&g.first===h.first){this.joinEdges2(a,u),this.joinEdges2(h.second,o.second);break}d.second=d.first.twin,g.second=g.first.twin;let f=this.getPointXYFromEdge(r.first),E=this.getPointXYFromEdge(r.second);if(d.first===o.first){let l=p(null,null);l.first=this.getNextDEdge(g.first,1),l.second=l.first.twin,l=this.checkEdge(l,f,E,1,!1),b(d,r),b(r,g),g=p(l.second,l.first)}else if(g.first===h.first){let l=p(null,null);l.first=this.getNextDEdge(d.first,0),l.second=l.first.twin,l=this.checkEdge(l,f,E,0,!1),g=p(r.second,r.first),b(r,d),d=p(l.second,l.first)}else{let l=p(null,null);l.first=this.getNextDEdge(d.first,0),l.second=l.first.twin,l=this.checkEdge(l,f,E,0,!1);let m=p(null,null);m.first=this.getNextDEdge(g.first,1),m.second=m.first.twin,m=this.checkEdge(m,f,E,1,!1);let P=this.getPointXYFromEdge(l.second),w=this.getPointXYFromEdge(m.second),D=this.inCircle(f,E,P,w);D===0&&(D=this.orientation(f,E,w)),0<D?(b(d,r),b(r,g),g=p(m.second,m.first)):(g=p(r.second,r.first),b(r,d),d=p(l.second,l.first))}this.deleteTwinEdges(r,!1)}}findEdgeClockwise(t,i,e,s,n,o){for(t[0]=s;;){i[0]=t[0],++i[0]===e.length&&(i[0]=0);let h=this.orientation(n,o,this.getPointXYFromEdge(e[i[0]]));if(h<=0)return h<0;t[0]=i[0]}}findEdgeCounterClockwise(t,i,e,s,n,o){for(i[0]=s;;){t[0]=i[0]!==0?i[0]:e.length,t[0]--;let h=this.orientation(n,o,this.getPointXYFromEdge(e[t[0]]));if(0<=h)return 0<h;i[0]=t[0]}}constraintFindFirstEdge(t,i,e,s){let n=[];{let a=this.getEdgeFromPoint(e),u=a;do{let f=this.getTwinEdge(u);if(this.getPointFromEdge(f)===s)return t[0]=f,i[0]=u,t[0].setMask(),i[0].setMask(),!1;n.push(f),u=this.getClockwiseEdge(u)}while(u!==a)}n.length<3&&_("add_constraint");let o=-1;for(let a=0,u=n.length;a<u;a++)this.isInfinitePointFromEdge(n[a])&&(o!==-1&&_("add_constraint"),o=a);let h=this.getPointXY(e),r=this.getPointXY(s),d,g;if(o!==-1)for(nt(n,0,o+1,n.length),n.pop(),this.orientation(h,r,this.getPointXYFromEdge(n[0]))===0&&_("add_constraint - point on constraint"),this.orientation(h,r,this.getPointXYFromEdge(n.at(-1)))===0&&_("add_constraint - point on constraint"),d=0,g=n.length-1;d+1!==g;){let a=d+g>>1,u=this.orientation(h,r,this.getPointXYFromEdge(n[a]));u===0&&_("add_constraint - point on constraint"),0<u?d=a:g=a}else{let a=0,u=this.orientation(h,r,this.getPointXYFromEdge(n[a]));if(u!==0)if(0<u){let f=[0],E=[0];this.findEdgeClockwise(f,E,n,a,h,r)||_("add_constraint"),d=f[0],g=E[0]}else{let f=[0],E=[0];this.findEdgeCounterClockwise(f,E,n,a,h,r)||_("add_constraint"),d=f[0],g=E[0]}else{a++,u=this.orientation(h,r,this.getPointXYFromEdge(n[a])),u<=0&&_("add_constraint");let f=[0],E=[0];this.findEdgeClockwise(f,E,n,a,h,r)||_("add_constraint"),d=f[0],g=E[0]}}return t[0]=n[d],i[0]=n[g],!0}triangulateConstraint(t,i,e,s){if(i===e)return;let n=e;for(let o=i;o!==e;++o)this.inCircle(this.getPointXYFromEdge(s.first),this.getPointXYFromEdge(s.second),this.getPointXYFromEdge(t[n]),this.getPointXYFromEdge(t[o]))<0&&(n=o);if(n!==e){let o=this.newPairEdge();this.join(s.first,t[n],1,1,o),t[n]=o.second,this.triangulateConstraint(t,n+1,e,o)}if(n!==i){let o=this.newPairEdge();this.join(t[n],s.second,1,0,o),this.triangulateConstraint(t,i,n-1,o)}}insideLine(t,i,e){return this.orientation(t,i,e)===0&&(i.x<t.x!=i.x<e.x||i.y<t.y!=i.y<e.y)}orientation(t,i,e){return x.orientationRobust(t,i,e)}inCircle(t,i,e,s){return x.inCircleRobust(t,i,e,s)}calculateCircleCenterFromThreePoints(t,i,e){return i.lt(t)&&(i=F(t,t=i)),e.lt(i)&&(e=F(i,i=e)),i.lt(t)&&(i=F(t,t=i)),x.calculateCircleCenterFromThreePoints(t,i,e)}compare(t,i){return 3*((M(t[0]<i[0])<<1)+M(t[0]>i[0]))+(M(t[1]<i[1])<<1)+M(t[1]>i[1])-1}caseFromCompare(t,i,e){return(this.compare(t,i)<<6)+(this.compare(t,e)<<3)+this.compare(i,e)}};function M(c){return c?1:0}function z(c,t,i){return c[i]!==t[i]?c[i]<t[i]:c[1-i]<t[1-i]}function X(c){return 255&c}S.c_aTableDelaunayTriangulationSolution=Uint8Array.from([41,74,0,0,0,0,0,0,0,206,0,0,0,0,0,0,0,0,0,0,65,0,0,0,0,0,33,33,65,0,0,0,0,0,0,0,193,0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,214,173,0,0,0,0,0,0,0,107,239,0,0,0,0,0,0,0,0,0,181,0,0,0,0,0,0,0,181,0,0,0,0,0,0,117,117,245,0,0,0,0,0,0,0,0,0,103,0,0,0,0,0,0,0,167,0,0,0,0,0,0,231,103,231,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,198,0,0,41,0,0,74,0,0,49,0,0,49,0,0,50,0,0,194,0,0,193,0,0,194,0,0,0,0,0,206,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,198,0,0,0,0,0,82,50,82,0,0,0,0,0,0,0,198,0,66,0,0,65,0,0,66,49,66,33,57,65,82,50,90,0,194,0,0,193,0,0,194,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,222,0,0,0,0,0,0,178,0,0,0,0,0,0,230,102,230,177,0,0,177,0,0,178,0,177,0,0,177,0,0,178,0,113,226,113,113,249,226,122,226,0,0,0,0,0,0,102,0,0,0,0,0,0,0,190,0,0,0,0,0,0,230,102,230,0,0,0,165,0,0,0,0,0,0,0,0,243,0,0,0,0,0,173,0,0,0,0,0,0,0,0,165,0,0,0,0,0,0,0,0,245,0,0,0,0,0,107,0,0,239,0,0,163,0,0,163,0,0,167,0,0,247,0,0,243,0,0,247,0,0,37,37,69,0,0,0,0,0,0,0,211,0,0,0,0,0,0,0,69,0,0,0,0,0,37,37,69,0,0,0,0,0,0,0,221,0,0,0,0,215,0,0,211,0,0,215,35,87,35,35,91,87,63,87,0,215,0,0,211,0,0,215,0,0,0,165,0,0,0,0,0,0,115,115,243,0,0,0,0,0,0,181,0,0,0,0,0,0,0,189,0,0,0,0,0,0,117,117,245,0,0,0,99,0,0,99,0,0,103,0,163,0,0,163,0,0,167,0,99,247,115,123,243,231,103,255]);var U=class{constructor(t){this.m_numberOfSets=t,this.m_elements=Array.from({length:t},(i,e)=>e),this.m_sizes=et(t,1)}getNumberOfSets(){return this.m_numberOfSets}connected(t,i){return this.findRoot(t)===this.findRoot(i)}connect(t,i){let e=this.findRoot(t),s=this.findRoot(i);return e!==s&&(this.m_sizes[e]<this.m_sizes[s]?(this.m_sizes[s]+=this.m_sizes[e],this.m_elements[e]=s):(this.m_sizes[e]+=this.m_sizes[s],this.m_elements[s]=e),--this.m_numberOfSets,!0)}connectRange(t,i,e){if(i!==e)for(let s=i;s<e;++s)this.connect(t[i],t[s])}size(){return this.m_elements.length}size1(t){return N(0),0}findRoot(t){let i=t;if(this.m_elements[i]!==i)do this.m_elements[i]=this.m_elements[this.m_elements[i]],i=this.m_elements[i];while(this.m_elements[i]!==i);return i}};function pt(){return I(Number.NaN,I([0,0,0],[0,0,0]))}function Et(c,t){if(c.first!==t.first)return c.first-t.first;let i=c.second.first,e=t.second.first;for(let s=0;s<3;++s)if(i[s]!==e[s])return i[s]-e[s];i=c.second.second,e=t.second.second;for(let s=0;s<3;++s)if(i[s]!==e[s])return i[s]-e[s];return 0}var H=class{getOperatorType(){return 10112}accelerateGeometry(t,i,e){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!1}executeMany(t,i,e,s){return new j(t,i,e,s)}execute(t,i,e,s=null){let n=new j(null,i,!1,e);return n.addGeometry(t),n.buildAlphaShape(s)}},j=class extends K{alphaShapeConstruct(t,i){let e=t.getEdgeCount(),s=new y({vd:this.m_vertexDescription});if(!s)throw new Error("alphaShapeConstruct");for(let n=0;n<e;++n){if(i[n]!==2)continue;let o=p(null,null);if(o.first=t.getEdge(n),o.second=t.getTwinEdge(o.first),i[t.getEdgeIndex(o.second)]!==1)continue;t.getPointXYFromEdge(o.first),s.startPath(t.getPointXYFromEdge(o.first));let h=n,r=o.second;for(;;){for(i[h]=3,r=t.getCounterClockwiseEdge(r);i[t.getEdgeIndex(r)]===1;)r=t.getCounterClockwiseEdge(r);if(r===o.first)break;s.lineTo(t.getPointXYFromEdge(r)),h=t.getEdgeIndex(r),r=t.getTwinEdge(r)}}return s}alphaShape(t,i){let e=t.getEdgeCount(),s=new Uint8Array(e);for(let n=0;n<e;++n){if(s[n]!==0)continue;let o=dt(),h=t.getEdge(n);o.p[0]=t.getPointFromEdge(h);let r=t.getClockwiseEdge(t.getTwinEdge(h));o.p[1]=t.getPointFromEdge(r);let d=t.getEdgeIndex(r),g=t.getClockwiseEdge(t.getTwinEdge(r));o.p[2]=t.getPointFromEdge(g);let a=t.getEdgeIndex(g),u=1;for(let f=0;f<3;++f)if(t.isInfinitePointFromPoint(o.p[f])){u=2;break}if(u===1){let f=C(x,3);for(let w=0;w<3;++w)f[w]=t.getPointXY(o.p[w]);let E=x.sqrDistance(f[0],f[1]),l=x.sqrDistance(f[1],f[2]),m=x.sqrDistance(f[2],f[0]),P=2*f[1].sub(f[0]).crossProduct(f[2].sub(f[0]));i<E*l*m/(P*P)&&(u=2)}s[n]=s[d]=s[a]=u}return this.alphaShapeConstruct(t,s)}alphaShapeAlphaOut(t,i){let e=t.getEdgeCount(),s=new Uint8Array(e),n=[],o=new U(t.getPointCount());for(let r=0;r<e;++r){if(s[r]!==0)continue;let d=dt(),g=t.getEdge(r);d.p[0]=t.getPointFromEdge(g);let a=t.getClockwiseEdge(t.getTwinEdge(g));d.p[1]=t.getPointFromEdge(a);let u=t.getEdgeIndex(a),f=t.getClockwiseEdge(t.getTwinEdge(a));d.p[2]=t.getPointFromEdge(f);let E=t.getEdgeIndex(f),l=1;for(let m=0;m<3;++m)if(t.isInfinitePointFromPoint(d.p[m])){l=2;break}if(l===1){let m=new Array(3);for(let Y=0;Y<3;++Y)m[Y]=t.getPointXY(d.p[Y]);let P=x.sqrDistance(m[0],m[1]),w=x.sqrDistance(m[1],m[2]),D=x.sqrDistance(m[2],m[0]),J=m[1].sub(m[0]).crossProduct(m[2].sub(m[0])),k=pt();k.first=P*w*D/(J*J),k.second.first[0]=r,k.second.first[1]=u,k.second.first[2]=E,k.second.second[0]=t.getPointIndex(d.p[0]),k.second.second[1]=t.getPointIndex(d.p[1]),k.second.second[2]=t.getPointIndex(d.p[2]),n.push(k),l=2}s[r]=s[u]=s[E]=l}n.sort((r,d)=>Et(r,d));let h=0;for(let r of n){if(o.getNumberOfSets()===1&&r.first!==h)break;s[r.second.first[0]]=s[r.second.first[1]]=s[r.second.first[2]]=1;let d=[r.second.second[0],r.second.second[1],r.second.second[2]];o.connectRange(d,0,3),h=r.first}return i&&(i[0]=.25*h),this.alphaShapeConstruct(t,s)}constructor(t,i,e,s){super(),this.m_multiPointForAttributes=null,this.m_inputGeometryCursor=null,this.m_index=-1,this.m_nDelaunayPoints=0,this.m_cDelaunay=new S,this.m_vertexDescription=null,this.m_progressTracker=s,this.m_alpha=Number.isNaN(i)||!Number.isFinite(i)||i<0?-1:i<Number.MIN_VALUE?0:i,this.m_bMerge=e,this.m_bDone=!1,this.m_inputGeometryCursor=t,this.prepareDelaunay()}prepareDelaunay(){this.m_nDelaunayPoints=0,this.m_cDelaunay.clear(),this.m_alpha!==0&&this.m_cDelaunay.prepare(it())}next(){if(this.m_bMerge){if(!this.m_bDone){let t=this.calculateAlphaShapeMerging(this.m_inputGeometryCursor,this.m_progressTracker);return this.m_bDone=!0,t}return null}if(!this.m_bDone){let t=this.m_inputGeometryCursor.next();if(t!==null)return v(t),A(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.calculateAlphaShape(t,this.m_progressTracker);this.m_bDone=!0}return null}tock(){return!0}getRank(){return 1}getGeometryID(){return this.m_index}calculateAlphaShapeMerging(t,i){let e;for(;e=t.next();)v(e),A(e),this.addGeometry(e);return this.buildAlphaShape()}calculateAlphaShape(t,i){return t.isEmpty()?new y({vd:t.getDescription()}):(this.prepareDelaunay(),this.addGeometry(t),this.buildAlphaShape())}buildAlphaShape(t=null){if(t&&(t[0]=this.m_alpha),this.m_alpha===0)return this.m_vertexDescription?new y({vd:this.m_vertexDescription}):new y;if(this.m_cDelaunay.removeDuplicates())for(let i=0,e=this.m_cDelaunay.getPointCount();i<e;++i)this.m_cDelaunay.setPointIndex(this.m_cDelaunay.getPoint(i),i);return this.m_cDelaunay.construct()?this.m_alpha<0?this.alphaShapeAlphaOut(this.m_cDelaunay,t):this.alphaShape(this.m_cDelaunay,this.m_alpha):this.m_vertexDescription?new y({vd:this.m_vertexDescription}):new y}addGeometry(t){if(v(t),A(t),this.m_alpha===0||(this.m_vertexDescription&&this.m_bMerge||(this.m_vertexDescription=t.getDescription(),this.m_vertexDescription.getAttributeCount()>1?this.m_multiPointForAttributes=new ot({vd:this.m_vertexDescription}):this.m_multiPointForAttributes=null),t.isEmpty()))return;let i=t.getGeometryType();if($(i)){let e=t,s=new x;for(let n=0,o=e.getPointCount();n<o;n++)e.queryXY(n,s),this.m_cDelaunay.addVertex(s,this.m_nDelaunayPoints++);this.m_multiPointForAttributes&&this.m_multiPointForAttributes.addPoints(e,0,-1)}else if(i===W.enumPoint){let e=t,s=e.getXY();this.m_cDelaunay.addVertex(s,this.m_nDelaunayPoints++),this.m_multiPointForAttributes&&this.m_multiPointForAttributes.add(e)}else _("bad geometry type")}},B=new H;function gt(c,t,i){return B.execute(c,t,null,i)}function at(c,t,i){let e=B.executeMany(new Q(c),t,i,null);return Array.from(e)}function ct(){return B.supportsCurves()}function Ct(c,t){let i=V(c),e=[0];return{alphaShape:O(gt(q(c),t,e),i),calculatedAlpha:e[0]}}function bt(c,t,i={}){let{merge:e=!1}=i,s=c.map(q),n=V(c);return at(s,t,e).map(o=>O(o,n))}var Dt=ct();export{Ct as execute,bt as executeMany,Dt as supportsCurves};
