import{a as M}from"./chunk-PWCKLYPC.js";import{c as L,d,e as b,g as T}from"./chunk-GYQWYHEG.js";import{b as v}from"./chunk-JC4DQSN3.js";import{d as y}from"./chunk-GNEAU6X4.js";import{b as p}from"./chunk-YOFFGXOB.js";import{a as S,c as h,f as g}from"./chunk-VTHXE323.js";var D=500,z=1e8,w=1280,F=12,O=30,k=15;function A(a){return g(this,null,function*(){let{view:e,sampleSize:n}=a;if(!a||!a.layer)throw new p("scale-range:missing-parameters","'layer' parameter is required");if(a.snapToLOD&&!e)throw new p("scale-range:missing-parameters","'view' parameter is required when 'snapToLOD' is true");a.forBinning&&v(a,"scale-range");let c=a,{layer:r}=c,i=h(c,["layer"]),l=a.forBinning?d:L,t=T(r,l,a.forBinning);if(!t)throw new p("scale-range:invalid-parameters","'layer' must be one of these types: "+b(l).join(", "));let o=S({layerAdapter:t},i);o.sampleSize=n||D,yield e?.when();let s=o.signal!=null?{signal:o.signal}:null;return yield t.load(s),o})}function B(a,e){let n=F,r=w/4,i=O,l=w/4,t=k,o=w/2,s=0,c=0,m=0,u=0;switch(a){case"point":case"multipoint":{let f=e;s=f.avgMinDistance??0,c=n,m=f.minDistance??0,u=r;break}case"polyline":{let f=e;s=f.avgLength??0,c=i,m=f.minLength??0,u=l;break}case"polygon":{let f=e;s=f.avgSize??0,c=t,m=f.minSize??0,u=o;break}}return{resolutionForMinScale:s>0?s/c:null,resolutionForMaxScale:m>0?m/u:null}}function R(a,e,n){let r=B(a.geometryType,e),i=n?.spatialReference||a.layer.spatialReference;return{minScale:y(r.resolutionForMinScale??0,i),maxScale:y(r.resolutionForMaxScale??0,i)}}function x(a,e,n=!0){if(a.constraints&&"effectiveLODs"in a.constraints){let r=a.constraints.effectiveLODs,i=n?r:r.slice().reverse(),l=null;for(let t of i)if(!(n?t.scale>e:t.scale<e)){l=t;break}return l}}function j(a,e,n,r){let{view:i,snapToLOD:l,layerAdapter:t}=a;if(l&&i){let o=x(i,e),s=x(i,n,!1);e=o?o.scale:e,n=s?s.scale:n}if(e<n)throw new p("scale-range:invalid","calculated minScale is less than maxScale.");return n>e/2&&(n=Math.floor(n/2)),e>z&&(e=0),t.geometryType!=="polygon"&&(n=0),{minScale:Math.ceil(e),maxScale:Math.floor(n),spatialStatistics:r}}function E(a){return g(this,null,function*(){let e=yield A(a),{view:n,sampleSize:r,layerAdapter:i,signal:l,filter:t}=e,o=yield i.getSampleFeatures({view:n,sampleSize:r,returnGeometry:!0,filter:t,signal:l},"json");if(!o?.length)throw new p("scale-range:insufficient-info","No features are available to calculate statistics");let s=yield M({features:o,geometryType:i.geometryType}),{minScale:c,maxScale:m}=R(i,s,n);return j(e,c,m,s)})}export{E as a};
