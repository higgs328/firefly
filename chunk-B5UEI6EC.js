import{b as s}from"./chunk-ZWHAEUE3.js";import{c as w}from"./chunk-NIRJWS2D.js";import{b as n}from"./chunk-YOFFGXOB.js";import{a as c,b as h,f as a}from"./chunk-VTHXE323.js";var d=class{constructor(){this._workerThread=null,this._destroyed=!1}initialize(){return a(this,null,function*(){let e=yield w("RasterWorker");this._destroyed?e.close():this._workerThread=e})}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}convertVectorFieldData(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r=yield this._workerThread.invoke("convertVectorFieldData",{pixelBlock:e.pixelBlock.toJSON(),type:e.dataType},o);return r?new s(r):null})}computeStatisticsHistograms(e,o){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");return this._workerThread.invoke("computeStatisticsHistograms",{pixelBlock:e.pixelBlock.toJSON()},o)}decode(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r=yield this._workerThread.invoke("decode",e,o);return r?new s(r):null})}symbolize(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r={extent:e.extent?.toJSON(),pixelBlock:e.pixelBlock?.toJSON(),simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},t=yield this._workerThread.invoke("symbolize",r,o);return t?new s(t):null})}updateSymbolizer(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r=e?.rendererJSON?.histograms;yield Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:e.toJSON(),histograms:r},o))})}updateRasterFunction(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");yield Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:e.toJSON()},o))})}process(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r=yield this._workerThread.invoke("process",{extent:e.extent?.toJSON(),primaryPixelSizes:e.primaryPixelSizes?.map(t=>t!=null?t.toJSON():null),primaryPixelBlocks:e.primaryPixelBlocks.map(t=>t!=null?t.toJSON():null),primaryRasterIds:e.primaryRasterIds},o);return r?new s(r):null})}stretch(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;let r={srcPixelBlock:e.pixelBlock.toJSON(),stretchParams:e.stretchParams},t=yield this._workerThread.invoke("stretch",r,o);return t?new s(t):null})}split(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;let r={srcPixelBlock:e.pixelBlock.toJSON(),tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel,useBilinear:e.useBilinear},t=yield this._workerThread.invoke("split",r,o);return t&&t.forEach((i,l)=>{t.set(l,i?s.fromJSON(i):null)}),t})}clipTile(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;let r=h(c({},e),{pixelBlock:e.pixelBlock.toJSON()}),t=yield this._workerThread.invoke("clipTile",r,o);return t?s.fromJSON(t):null})}estimateStatisticsHistograms(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;let r={srcPixelBlock:e.pixelBlock.toJSON()};return yield this._workerThread.invoke("estimateStatisticsHistograms",r,o)})}mosaicAndTransform(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");if(!e?.srcPixelBlocks?.length)return{pixelBlock:null};let r=h(c({},e),{srcPixelBlocks:e.srcPixelBlocks.map(i=>i!=null?i.toJSON():null)}),t=yield this._workerThread.invoke("mosaicAndTransform",r,o);return{pixelBlock:t.pixelBlock?new s(t.pixelBlock):null,localNorthDirections:t.localNorthDirections}})}createFlowMesh(e,o){return a(this,null,function*(){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r={buffer:e.flowData.data.buffer,maskBuffer:e.flowData.mask.buffer,width:e.flowData.width,height:e.flowData.height},{meshType:t,simulationSettings:i}=e,l=yield this._workerThread.invoke("createFlowMesh",{meshType:t,flowData:r,simulationSettings:i},h(c({},o),{transferList:[r.buffer,r.maskBuffer]}));return{vertexData:new Float32Array(l.vertexBuffer),indexData:new Uint32Array(l.indexBuffer)}})}getProjectionOffsetGrid(e,o){if(!this._workerThread)throw new n("raster-jobhandler:no-connection","no available worker connection");let r=e.datumTransformation!=null?e.datumTransformation.steps.map(l=>({wkid:l.wkid,wkt:l.wkt,isInverse:l.isInverse})):null,t=e.rasterTransform!=null?e.rasterTransform.toJSON():null,i={projectedExtent:e.projectedExtent.toJSON(),srcBufferExtent:e.srcBufferExtent.toJSON(),pixelSize:e.pixelSize,hasWrapAround:e.hasWrapAround,spacing:e.spacing,datumTransformationSteps:r,rasterTransform:t,isAdaptive:e.isAdaptive,includeGCSGrid:e.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",i,o)}};export{d as a};
